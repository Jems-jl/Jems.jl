var documenterSearchIndex = {"docs":
[{"location":"Opacity/#Opacity","page":"Opacity","title":"Opacity","text":"","category":"section"},{"location":"Opacity/","page":"Opacity","title":"Opacity","text":"The Opacity module of Jems handles all things related to the opacity of stellar matter.","category":"page"},{"location":"Opacity/","page":"Opacity","title":"Opacity","text":"Modules = [Jems.Opacity]","category":"page"},{"location":"Opacity/#Jems.Opacity.AbstractOpacity","page":"Opacity","title":"Jems.Opacity.AbstractOpacity","text":"abstract type AbstractOpacity\n\nAbstract supertype from which all defined opacity laws must derive, ie:\n\nstruct MyOpacity <: AbstractOpacity\n\n\n\n\n\n","category":"type"},{"location":"Opacity/#Jems.Opacity.get_opacity_resultsTρ-Union{Tuple{TT}, Tuple{Jems.Opacity.SimpleElectronScatteringOpacity, TT, TT, AbstractVector{<:TT}, Vector{Symbol}}} where TT<:Real","page":"Opacity","title":"Jems.Opacity.get_opacity_resultsTρ","text":"get_opacity_resultsTP(opacity::SimpleElectronScatteringOpacity, lnT::TT, lnP::TT, xa::Vector{<:TT},\n                        species::Vector{Symbol})::TT where {TT<:Real}\n\nEvaluates the opacity of the current mixture with mass fractions xa, species symbols species (both these should be of length nspecies), the natural log of temperature and pressure lnT, lnP, and the opacity law opacity.\n\n\n\n\n\n","category":"method"},{"location":"style/#Style-Guide","page":"Style Guide","title":"Style Guide","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"When developing Jems, please take into account the following style pointers.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"We use 4 spaces as the indent marker, and use a line length of 120. This is not strictly enforced, but try to keep overrunning lines to a minimum.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Docstrings are demarked by three double quotes:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    my_func(a::Number)\n\nThis function does something cool with number `a`.\n\"\"\"","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Comments are marked with the hashtag and a space:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"# this loop does good stuff!\nfor i = 1:10\n    a += 1\nend","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Inline comments should be separated by at least two spaces:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"c = a + b  # this is high level stuff!","category":"page"},{"location":"style/#JuliaFormatter","page":"Style Guide","title":"JuliaFormatter","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The file .JuliaFormatter.toml is be used in conjunction with JuliaFormatter.jl to automatically format source files according to our adopted style:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"JuliaFormatter.format(\".\")  # formats the whole directory of source files","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The main function of the formatter is that it will automatically fold long lines, and inserts spaces around operators. One disadvantance is that it ignores comments and does not yet handle docstrings (even if the .toml file explicitly says to include docstrings, this is a bug).","category":"page"},{"location":"Evolution/#Evolution","page":"Evolution","title":"Evolution","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"The Evolution module of Jems contains the basic tools needed to combine all other modules to perform stellar evolution. It allows a fully customizable definition of the equations that are solved together with their boundary conditions.","category":"page"},{"location":"Evolution/#Equations.jl","page":"Evolution","title":"Equations.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Equations.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.equationContinuity-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.equationContinuity","text":"equationContinuity(sm::StellarModel, k::Int,\n                   varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n                   eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n                   rates::Matrix{TT},\n                   κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of mass continuity, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with StellarModels.TypeStableEquation\n\nReturns\n\nResidual of comparing dr^3/dm with 3/(4πρ)\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationHSE-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.equationHSE","text":"equationHSE(sm::StellarModel, k::Int,\n            varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n            eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n            rates::Matrix{TT},\n            κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of hydrostatic equilibrium. Evaluates for cell k of StellarModel sm to what degree hydrostatic equilibrium is satisfied.\n\nArguments\n\nsm: Stellar Model\nk: cell number to consider\nvarm1: Matrix holding the dual numbers of the previous cell (k-1)\nvar00: Matrix holding the dual numbers of this cell (k)\nvarp1: Matrix holding the dual numbers of the next cell (k+1)\neosm1: EOSResults object holding the results of the EOS evaluation of the previous cell (k-1)\neos00: EOSResults object holding the results of the EOS evaluation of the current cell (k)\neosp1: EOSResults object holding the results of the EOS evaluation of the next cell (k+1)\nκm1: Opacity evaluated at the previous cell (k-1)\nκ00: Opacity evaluated at the current cell (k)\nκp1: Opacity evaluated at the next cell (k+1)\n\nReturns\n\nResidual of comparing dlnP/dm with -GM/4πr^4, where the latter is evaluated at the face of cell k and k+1.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationLuminosity-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.equationLuminosity","text":"equationLuminosity(sm::StellarModel, k::Int,\n                   varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n                   eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n                   rates::Matrix{TT},\n                   κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of energy generation, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with StellarModels.TypeStableEquation\n\nReturns\n\nResidual of comparing dL/dm with ϵnuc - cₚ * dT/dt - (δ / ρ) * dP/dt\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationT-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.equationT","text":"equationT(sm::StellarModel, k::Int,\n          varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n          eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n          rates::Matrix{TT},\n          κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of energy transport, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with StellarModels.TypeStableEquation\n\nReturns\n\nResidual of comparing dlnT/dm with -∇*GMT/4πr^4P, where the latter is evaluation at the face of cell k and k+1.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equation_composition-Tuple{Jems.StellarModels.StellarModel, Int64, Symbol}","page":"Evolution","title":"Jems.Evolution.equation_composition","text":"equation_composition(sm::StellarModel, k::Int, iso_name::Symbol,\n                     varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n                     eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n                     rates::Matrix{TT},\n                     κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation for composition evolution for isotope iso_name, evaluated for cell k of StellarModel sm.\n\nArguments\n\nTBD\n\nReturns\n\nResidual of comparing dX_i/dt with its computed reaction rate\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Evaluation.jl","page":"Evolution","title":"Evaluation.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Evaluation.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.eval_cell_eqs!-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.eval_cell_eqs!","text":"eval_cell_eqs(sm::StellarModel, k::Int, ind_vars_view::Vector{<:TT}) where{TT<:Real}\n\nEvaluates the stellar structure equations of the stellar model, sm, at cell k, given the view of the independent variables, ind_vars_view.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.eval_jacobian_eqs!-Tuple{Jems.StellarModels.StellarModel}","page":"Evolution","title":"Jems.Evolution.eval_jacobian_eqs!","text":"eval_jacobian_eqs!(sm::StellarModel)\n\nEvaluates the whole Jacobian matrix and equations of the given StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.eval_jacobian_eqs_row!-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.eval_jacobian_eqs_row!","text":"eval_jacobian_eqs_row!(sm::StellarModel, k::int)\n\nEvaluates row k of the Jacobian matrix of the given StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Solver.jl","page":"Evolution","title":"Solver.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Solver.jl\"]","category":"page"},{"location":"Evolution/#EvolutionLoop.jl","page":"Evolution","title":"EvolutionLoop.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/EvolutionLoop.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.cycle_step_info!-Tuple{Jems.StellarModels.StellarModel}","page":"Evolution","title":"Jems.Evolution.cycle_step_info!","text":"cycle_step_info!(sm::StellarModel)\n\nMoves the model info of the StellarModel sm over one state: start step info -> end step info -> previous step info -> start step info.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.do_evolution_loop!-Tuple{Jems.StellarModels.StellarModel}","page":"Evolution","title":"Jems.Evolution.do_evolution_loop!","text":"do_evolution_loop(sm::StellarModel)\n\nPerforms the main evolutionary loop of the input StellarModel sm. It continues taking steps until one of the termination criteria is reached (defined in sm.opt.termination).\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.get_dt_next-Tuple{Jems.StellarModels.StellarModel}","page":"Evolution","title":"Jems.Evolution.get_dt_next","text":"get_dt_next(sm::StellarModel)\n\nComputes the timestep of the next evolutionary step to be taken by the StellarModel sm by considering all timestep controls (sm.opt.timestep).\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.set_step_info!-Tuple{Jems.StellarModels.StellarModel, Jems.StellarModels.StellarStepInfo}","page":"Evolution","title":"Jems.Evolution.set_step_info!","text":"set_end_step_info(sm::StellarModel)\n\nSets the StellarStepInfo sifrom current state of the StellarModelsm`.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.uncycle_step_info!-Tuple{Jems.StellarModels.StellarModel}","page":"Evolution","title":"Jems.Evolution.uncycle_step_info!","text":"uncycle_step_info!(sm::StellarModel)\n\nMoves the model info of the StellarModel sm back one state: start step info <- end step info <- previous step info <- start step info.\n\n\n\n\n\n","category":"method"},{"location":"Constants/#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"Constants/","page":"Constants","title":"Constants","text":"The Constants module of Jems defines a common set of physical and mathematical constants for use across the package.","category":"page"},{"location":"Constants/","page":"Constants","title":"Constants","text":"Modules = [Jems.Constants]","category":"page"},{"location":"Chem/#Chem","page":"Chem","title":"Chem","text":"","category":"section"},{"location":"Chem/","page":"Chem","title":"Chem","text":"The Chemistry module of Jems handles all things related to chemical mixtures and isotopes.","category":"page"},{"location":"Chem/","page":"Chem","title":"Chem","text":"Modules = [Jems.Chem]","category":"page"},{"location":"Chem/#Jems.Chem.Isotope","page":"Chem","title":"Jems.Chem.Isotope","text":"struct Isotope\n\nStructure containing basic info of an isotope:\n\nZ: atomic number (# protons)\nA: mass number (# protons + neutrons)\nname: its name (eg \"Hydrogen\")\nmass: atomic weight in amu\n\n\n\n\n\n","category":"type"},{"location":"Chem/#Jems.Chem.get_isotope_list-Tuple{}","page":"Chem","title":"Jems.Chem.get_isotope_list","text":"get_isotope_list()\n\nReturns a dictionary of all included isotopes in Jems, mapping symbols to Isotope objects.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#EOS","page":"EOS","title":"EOS","text":"","category":"section"},{"location":"EOS/","page":"EOS","title":"EOS","text":"The EOS module of Jems handles all things related to the equation of state of stellar matter.","category":"page"},{"location":"EOS/","page":"EOS","title":"EOS","text":"Modules = [Jems.EOS]","category":"page"},{"location":"EOS/#Jems.EOS.AbstractEOS","page":"EOS","title":"Jems.EOS.AbstractEOS","text":"abstract type AbstractEOS\n\nAbstract supertype from which all equations of state definitions must derive, ie:\n\nstruct MyEOS <: AbstractEOS\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.EOSResults","page":"EOS","title":"Jems.EOS.EOSResults","text":"mutable struct EOSResults{T1<:Real}\n\nStructure that holds various results from the evaluation of the EOS of a certain cell.\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.IdealEOS","page":"EOS","title":"Jems.EOS.IdealEOS","text":"struct IdealEOS <: AbstractEOS\n\nInterface of an Ideal gas equation of state\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.get_μ_IdealEOS-Union{Tuple{TT}, Tuple{AbstractVector{TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.get_μ_IdealEOS","text":"get_μ_IdealEOS(xa, species)\n\ncomputes the molecular weight of the mixture xa, given and list of species.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#Jems.EOS.set_EOS_resultsTρ!-Union{Tuple{TT}, Tuple{Jems.EOS.IdealEOS, Jems.EOS.EOSResults{TT}, TT, TT, AbstractVector{TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.set_EOS_resultsTρ!","text":"set_EOS_resultsTP!(eos::IdealEOS, r::EOSResults{TT}, lnT::TT, lnP::TT, xa::AbstractVector{TT},\n                       species::Vector{Symbol}) where {TT<:Real}\n\nComputes thermodynamical quantities of a mixture xa at temperature lnT and pressure lnP, given the ideal equation of state eos and list of species. The results are stored in the EOSResults object r.\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Plotting.md","page":"Plotting.md","title":"Plotting.md","text":"","category":"section"},{"location":"Plotting/","page":"Plotting.md","title":"Plotting.md","text":"This module provides live plotting routines for simulations","category":"page"},{"location":"Plotting/#Plotting.jl","page":"Plotting.md","title":"Plotting.jl","text":"","category":"section"},{"location":"Plotting/","page":"Plotting.md","title":"Plotting.md","text":"Modules = [Jems.Plotting]\nPages = [\"Plotting/Plotting.jl\"]","category":"page"},{"location":"Plotting/#Jems.Plotting.end_of_evolution-Tuple{Jems.StellarModels.StellarModel}","page":"Plotting.md","title":"Jems.Plotting.end_of_evolution","text":"end_of_evolution(sm::StellarModel)\n\nPerform end of evolution actions\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Jems.Plotting.update_plotting!-Tuple{Jems.StellarModels.StellarModel}","page":"Plotting.md","title":"Jems.Plotting.update_plotting!","text":"update_plots!(sm::StellarModel)\n\nUpdates all plots currently being displayed, by collecting appropriate data and notifying observables\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Init.jl","page":"Plotting.md","title":"Init.jl","text":"","category":"section"},{"location":"Plotting/","page":"Plotting.md","title":"Plotting.md","text":"Modules = [Jems.Plotting]\nPages = [\"Plotting/Init.jl\"]","category":"page"},{"location":"Plotting/#Jems.Plotting.init_figure!-Tuple{Jems.StellarModels.StellarModel}","page":"Plotting.md","title":"Jems.Plotting.init_figure!","text":"init_figure!(sm::StellarModel)\n\nInitializes the plotting figure and adds axes\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Jems.Plotting.init_plots!-Tuple{Jems.StellarModels.StellarModel}","page":"Plotting.md","title":"Jems.Plotting.init_plots!","text":"init_plots(sm::StellarModel)\n\nSets up all observables to be traced this run, and creates the figure and axis where they will be plotted\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#History.jl","page":"Plotting.md","title":"History.jl","text":"","category":"section"},{"location":"Plotting/","page":"Plotting.md","title":"Plotting.md","text":"Modules = [Jems.Plotting]\nPages = [\"Plotting/History.jl\"]","category":"page"},{"location":"Plotting/#Jems.Plotting.create_history_observables!-Tuple{Jems.StellarModels.JemsPlot, Dict, Dict}","page":"Plotting.md","title":"Jems.Plotting.create_history_observables!","text":"create_history_observables!(sm::StellarModel, plot::StellarModels.JemsPlot)\n\ncreates the x and y observables and adds them to the observable list of the given plot\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Jems.Plotting.make_history_plot!-Tuple{Makie.Axis, Observables.Observable, Dict{Symbol, Observables.Observable}}","page":"Plotting.md","title":"Jems.Plotting.make_history_plot!","text":"init_HR_plot!(ax::Axis, xval::Observable, yval::Observable; line_kwargs=Dict())\n\nSets up the plot elements for an history plot\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Jems.Plotting.update_history_plot!-Tuple{Jems.StellarModels.JemsPlot, Jems.StellarModels.StellarModel}","page":"Plotting.md","title":"Jems.Plotting.update_history_plot!","text":"function update_history_plot!(plot::StellarModels.JemsPlot, sm::StellarModel)\n\nUpdates the given plot with relevant history data from the stellar model sm.\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#HRD.jl","page":"Plotting.md","title":"HRD.jl","text":"","category":"section"},{"location":"Plotting/","page":"Plotting.md","title":"Plotting.md","text":"Modules = [Jems.Plotting]\nPages = [\"Plotting/HRD.jl\"]","category":"page"},{"location":"Plotting/#Jems.Plotting.create_HR_observables!-Tuple{Jems.StellarModels.JemsPlot, Jems.StellarModels.StellarModel}","page":"Plotting.md","title":"Jems.Plotting.create_HR_observables!","text":"create_HR_observables!(sm::StellarModel, plot::StellarModels.JemsPlot)\n\nCreates teff and L observables and adds them to the observable list of the given plot\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Jems.Plotting.make_HR_plot!-Tuple{Makie.Axis, Vararg{Observables.Observable, 4}}","page":"Plotting.md","title":"Jems.Plotting.make_HR_plot!","text":"init_HR_plot!(ax::Axis, Teff::Observable, L::Observable, Teff_now::Observable, L_now::Observable;\n                  line_kwargs=Dict(), scatter_kwargs=Dict())\n\nSets up the plot elements for an HRD\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Jems.Plotting.update_HR_plot!-Tuple{Jems.StellarModels.JemsPlot, Jems.StellarModels.StellarModel}","page":"Plotting.md","title":"Jems.Plotting.update_HR_plot!","text":"function update_HR_plot!(plot::StellarModels.JemsPlot, sm::StellarModel)\n\nUpdates the given plot with the relevant HR data from the stellar model sm.\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Profile.jl","page":"Plotting.md","title":"Profile.jl","text":"","category":"section"},{"location":"Plotting/","page":"Plotting.md","title":"Plotting.md","text":"Modules = [Jems.Plotting]\nPages = [\"Plotting/Profile.jl\"]","category":"page"},{"location":"Plotting/#Jems.Plotting.create_profile_observables!-Tuple{Jems.StellarModels.JemsPlot, Dict, Dict}","page":"Plotting.md","title":"Jems.Plotting.create_profile_observables!","text":"function create_profile_observables!(plot::StellarModels.JemsPlot, xvals::Dict, yvals::Dict;\n                                     alt_yvals::Dict=nothing)\n\nCreates relevant profile observables for this plot given xvals, yvals and  optionally alt_yvals for the right hand axis.\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Jems.Plotting.make_profile_plot!-Tuple{Makie.Axis, Observables.Observable, Dict{Symbol, Observables.Observable}}","page":"Plotting.md","title":"Jems.Plotting.make_profile_plot!","text":"function make_profile_plot!(ax::Axis, xvals::Observable, yvals::Dict{Symbol,Observable};\n                            xlabel::AbstractString=\"\", ylabels::Dict{Symbol,<:AbstractString}=Dict(),\n                            alt_ax::Axis=nothing, alt_yvals::Dict{Symbol,Observable}=nothing,\n                            alt_ylabels::Dict{Symbol,<:AbstractString}=nothing,\n                            line_kwargs=Dict())\n\nPlots a line for each entry in the yvals dict, and puts the given ylabels in a legend. The alt_ax is optional for the right hand side axis.\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Jems.Plotting.update_profile_plot!-Tuple{Jems.StellarModels.JemsPlot, Jems.StellarModels.StellarModel}","page":"Plotting.md","title":"Jems.Plotting.update_profile_plot!","text":"update_profile_plot!(plot::StellarModels.JemsPlot, sm::StellarModel)\n\nupdates the observables of this plot with relevant data of the stellar model sm.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#StellarModels","page":"StellarModels","title":"StellarModels","text":"","category":"section"},{"location":"StellarModels/","page":"StellarModels","title":"StellarModels","text":"The Chemistry module of Jems handles all things related to chemical mixtures and isotopes.","category":"page"},{"location":"StellarModels/#StellarModel.jl","page":"StellarModels","title":"StellarModel.jl","text":"","category":"section"},{"location":"StellarModels/","page":"StellarModels","title":"StellarModels","text":"Modules = [Jems.StellarModels]\nPages = [\"StellarModels/StellarModel.jl\"]","category":"page"},{"location":"StellarModels/#Jems.StellarModels.StellarModel","page":"StellarModels","title":"Jems.StellarModels.StellarModel","text":"mutable struct StellarModel{TN<:Real,TD<:Real,TEOS<:EOS.AbstractEOS,TKAP<:Opacity.AbstractOpacity}\n\nAn evolutionary model for a star, containing information about the star's current state, as well as the independent variables of the model and its equations.\n\nThe struct has four parametric types, TN for 'normal' numbers, TD for dual numbers used in automatic differentiation, TEOS for the type of EOS being used and TKAP for the type of opacity law being used.\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.StellarModel-Tuple{Vector{Symbol}, Vector{Function}, Int64, Int64, Vector{Function}, Jems.NuclearNetworks.NuclearNetwork, Jems.EOS.AbstractEOS, Jems.Opacity.AbstractOpacity}","page":"StellarModels","title":"Jems.StellarModels.StellarModel","text":"StellarModel(varnames::Vector{Symbol}, structure_equations::Vector{Function},\n             nvars::Int, nspecies::Int, nz::Int, eos::AbstractEOS, opacity::AbstractOpacity)\n\nConstructor for a StellarModel instance, using varnames for the independent variables, functions of the structure_equations to be solved, number of independent variables nvars, number of species in the network nspecies number of zones in the model nz and an iterface to the EOS and Opacity laws.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.StellarStepInfo","page":"StellarModels","title":"Jems.StellarModels.StellarStepInfo","text":"mutable struct StellarStepInfo{TN<:Real}\n\nInformation used for a simulation step. A single stellar model can have three different objects of type StellarStepInfo, containing information from the previous step, information right before the Newton solver, and information after the Newton solver has completed.\n\nThe struct has one parametric type, TN to represent 'normal' numbers. No fields here need to have dual numbers as these will not be used in automatic differentiation routines.\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.TypeStableEquation","page":"StellarModels","title":"Jems.StellarModels.TypeStableEquation","text":"struct TypeStableEquation{TS,TD<:Real}\n\nStructure that wraps a stellar structure equation into a type stable object, using FunctionWrappers.jl. This requires that the stellar structure equations have the following signature:\n\nfunction structure_equation(::TS, ::Int,\n                            ::Matrix{TD}, ::Matrix{TD}, ::Matrix{TD},\n                            ::EOSResults{TD}, ::EOSResults{TD}, ::EOSResults{TD}\n                            ::Matrix{TD},\n                            ::TD, ::TD, ::TD)::TD\n\nFor typical usage, TS is the concrete type of StellarModel, and TD the type of dual number being used for automatic differentiation. The function must return an object of type TD, the result of the equation.\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.adjusted_stellar_model_data-Tuple{Any, Int64, Int64}","page":"StellarModels","title":"Jems.StellarModels.adjusted_stellar_model_data","text":"adjusted_stellar_model_data(sm, new_nz::Int, new_nextra::Int)\n\nReturns a new copy of sm with an adjusted allocated size. This creates a full duplicate without removing the old stellar model, which is not very memory friendly. One possible optimization for the future. The new model is created to have new_nz zones with an extra padding of new_nextra zones to allow for remeshing. The new model will copy the contents of\n\nind_vars\nmstar\nm\ndm\ntime\ndt\nmodel_number\npsi, ssi, esi\nopt\n\nAs well as the nuclear network, opacity and EOS.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Options.jl","page":"StellarModels","title":"Options.jl","text":"","category":"section"},{"location":"StellarModels/","page":"StellarModels","title":"StellarModels","text":"Modules = [Jems.StellarModels]\nPages = [\"StellarModels/Options.jl\"]","category":"page"},{"location":"StellarModels/#Jems.StellarModels.IOOptions","page":"StellarModels","title":"Jems.StellarModels.IOOptions","text":"mutable struct IOOptions\n\nSubstructure of Options containing controls relating to input/output of data\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.Options","page":"StellarModels","title":"Jems.StellarModels.Options","text":"mutable struct Options\n\nStructure containing tweakable controls of Jems.\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.PlottingOptions","page":"StellarModels","title":"Jems.StellarModels.PlottingOptions","text":"mutable struct PlottingOptions\n\nOptions relating to the live plotting of the simulation\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.RemeshOptions","page":"StellarModels","title":"Jems.StellarModels.RemeshOptions","text":"mutable struct RemeshOptions\n\nSubstructure of Options containing controls relating to remeshing\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.SolverOptions","page":"StellarModels","title":"Jems.StellarModels.SolverOptions","text":"mutable struct SolverOptions\n\nSubstructure of Options containing controls relating to the Newton solver\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.TerminationOptions","page":"StellarModels","title":"Jems.StellarModels.TerminationOptions","text":"mutable struct TerminationOptions\n\nSubstructure of Options containing controls relating to termination of the simulation\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.TimestepOptions","page":"StellarModels","title":"Jems.StellarModels.TimestepOptions","text":"mutable struct TimestepOptions\n\nSubstructure of Options containing controls relating to timestepping\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.set_options!-Tuple{Jems.StellarModels.Options, String}","page":"StellarModels","title":"Jems.StellarModels.set_options!","text":"set_options!(opt::Options, toml_path::String)\n\nSets the controls in opt to the values supplied in the TOML file toml_path, containing key: value pairs. Invalid keys are not allowed, and an Exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#InitialCondition.jl","page":"StellarModels","title":"InitialCondition.jl","text":"","category":"section"},{"location":"StellarModels/","page":"StellarModels","title":"StellarModels","text":"Modules = [Jems.StellarModels]\nPages = [\"StellarModels/InitialCondition.jl\"]","category":"page"},{"location":"StellarModels/#Jems.StellarModels.RungeKutta_LaneEmden-Tuple{Any}","page":"StellarModels","title":"Jems.StellarModels.RungeKutta_LaneEmden","text":"RungeKutta_LaneEmden(n)\n\nComputes the solution of the Lane-Emden equation for polytropic index n until the first zero by returning xvals, containing ξ values; yvals, containing the corresponding function values θn; and zvals, containing the derivative. This naming convention for x (=independent variable), y (=corresponding solution values) and z (=corresponding derivative values) is used throughout this function. The Lane-Emden equation is solved by performing the Runge-Kutta method of order 4. The stepsize is allowed to decrease as the function reaches the first zero. The function takes care of the core boundary conditions at ξ=0. The last ξ value (i.e. the first zero of the Lane-Emden solution) is calculated by linearly extrapolating the last two points of the solution. This first zero ξ1 can be found as xvals[end].\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.get_logdq-Union{Tuple{TT}, Tuple{Int64, Int64, TT, TT, TT, Int64}} where TT<:Real","page":"StellarModels","title":"Jems.StellarModels.get_logdq","text":"get_logdq(k::Int, nz::Int, logdq_low::TT, logdq_high::TT, numregion::Int)::TT where {TT<:Real}\n\nComputes the logarithm mass chunk logdq for zone k of a profile with total zones nz, while keeping in mind to better resolve the first and last numregion zones of the profile. It linearly interpolates the value from the inputs logdq_low and logdq_high in these regions, while keeping logdq_high in the middle zones.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.getlnT_NewtonRhapson-NTuple{6, Any}","page":"StellarModels","title":"Jems.StellarModels.getlnT_NewtonRhapson","text":"getlnT_NewtonRhapson(lnT_initial, lnρ, P, xa, species, eos)\n\nComputes the temperature lnT starting from a density lnρ, a pressure P, a composition xa, a species species and an equation of state eos. The equation of state gives us the pressure,  given a certain temperature and density. The idea is to match this pressure with the given pressure P by fitting the temperature. Starting from an initial guess lnT_initial,  the Newton-Rhapson method is used to converge to the final temperature in an interative way. Each iteration, a new lnT is computed according to the Newton-Rhapson formula using the derivative dlnP/dlnT. Next, based on this new lnT, the equation of state returns a new pressure. The algorithm stops when the difference between the calculated pressure and the given pressure is smaller than a certain threshold. The temperature at which this occurs is returned.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.n_polytrope_initial_condition!-Tuple{Any, Jems.StellarModels.StellarModel, Real, Real}","page":"StellarModels","title":"Jems.StellarModels.n_polytrope_initial_condition!","text":"n_polytrope_initial_condition(n,sm::StellarModel, M::Real, R::Real; initial_dt=100 * SECYEAR)\n\nInitializes a stellar model sm with values corresponding to a polytrope of index n, setting the independent variables sm.ind_vars, etc. accordingly. Also sets the initial timestep to be taken, initial_dt. The function first calls the solution to the Lane-Emden equation for index n and then sets radii, densities, pressures and luminosities.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#IO.jl","page":"StellarModels","title":"IO.jl","text":"","category":"section"},{"location":"StellarModels/","page":"StellarModels","title":"StellarModels","text":"Modules = [Jems.StellarModels]\nPages = [\"StellarModels/IO.jl\"]","category":"page"},{"location":"StellarModels/#Jems.StellarModels.get_history_dataframe_from_hdf5-Tuple{Any}","page":"StellarModels","title":"Jems.StellarModels.get_history_dataframe_from_hdf5","text":"get_history_dataframe_from_hdf5(hdf5_filename)\n\nReturns a DataFrame object built from an hdf5 file, named hdf5_filename.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.get_profile_dataframe_from_hdf5-Tuple{Any, Any}","page":"StellarModels","title":"Jems.StellarModels.get_profile_dataframe_from_hdf5","text":"get_profile_dataframe_from_hdf5(hdf5_filename, profile_name)\n\nReturns a DataFrame object built from an hdf5 file, named hdf5_filename, considering the column named profile_name\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.get_profile_names_from_hdf5-Tuple{Any}","page":"StellarModels","title":"Jems.StellarModels.get_profile_names_from_hdf5","text":"get_profile_names_from_hdf5(hdf5_filename)\n\nRetruns the column names of the profile data contained in the hdf5 file hdf5_filename.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.history_get_ind_vars_edge_value-Tuple{Jems.StellarModels.StellarModel, Symbol, Symbol}","page":"StellarModels","title":"Jems.StellarModels.history_get_ind_vars_edge_value","text":"history_get_ind_vars_edge_value(sm::StellarModel, var_symbol::Symbol, edge::Symbol)\n\nReturns the value of the independent variable var_symbol at either the surface or the center of the StellarModel sm. edge can be either :surface or :center.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.profile_get_ind_vars_value-Tuple{Jems.StellarModels.StellarModel, Symbol, Int64}","page":"StellarModels","title":"Jems.StellarModels.profile_get_ind_vars_value","text":"profile_get_ind_vars_value(sm::StellarModel, var_symbol::Symbol, k::Int)\n\nReturns the value of the variable Symbol var_symbol at cell number k of the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.write_data-Tuple{Jems.StellarModels.StellarModel}","page":"StellarModels","title":"Jems.StellarModels.write_data","text":"write_data(dm::StellarModel)\n\nSaves data (history/profile) for the current model, as required by the settings in sm.opt.io.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Remesher.jl","page":"StellarModels","title":"Remesher.jl","text":"","category":"section"},{"location":"StellarModels/","page":"StellarModels","title":"StellarModels","text":"Modules = [Jems.StellarModels]\nPages = [\"StellarModels/Remesher.jl\"]","category":"page"},{"location":"StellarModels/#Jems.StellarModels.remesher!-Tuple{Jems.StellarModels.StellarModel}","page":"StellarModels","title":"Jems.StellarModels.remesher!","text":"remesher!\n\nTodo\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#PlotterInterface.jl","page":"StellarModels","title":"PlotterInterface.jl","text":"","category":"section"},{"location":"StellarModels/","page":"StellarModels","title":"StellarModels","text":"Modules = [Jems.StellarModels]\nPages = [\"StellarModels/PlotterInterface.jl\"]","category":"page"},{"location":"StellarModels/#Jems.StellarModels.Plotter","page":"StellarModels","title":"Jems.StellarModels.Plotter","text":"mutable struct Plotter\n\nStructure that contains references to windows, axes and observables to be plotted with Jems.Plotting\n\n\n\n\n\n","category":"type"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"EditURL = \"../../examples/NuclearBurning.jl\"","category":"page"},{"location":"NuclearBurning/#NuclearBurning.jl","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"This notebook provides a simple example of a star with simplified microphysics undergoing nuclear burning. Import all necessary Jems modules. We will also do some benchmarks, so we import BenchmarkTools as well.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"using BenchmarkTools\nusing Jems.Chem\nusing Jems.Constants\nusing Jems.EOS\nusing Jems.Opacity\nusing Jems.NuclearNetworks\nusing Jems.StellarModels\nusing Jems.Evolution\nusing Jems.ReactionRates","category":"page"},{"location":"NuclearBurning/#Model-creation","page":"NuclearBurning.jl","title":"Model creation","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We start by creating the stellar model. In this example we consider a model with 6 independent variables, two of which correspond to composition. The independent variables here are ln(P), ln(T), ln(r), the luminosity L and the mass fractions of Hydrogen and Helium.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"The Evolution module has pre-defined equations corresponding to these variables, which we provide here. For now, only a simple (fully ionized) ideal gas law EOS is available. Similarly, only a simple simple electron scattering opacity equal to kappa=02(1+X)mathrmcm^2g^-1 is available.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"varnames = [:lnρ, :lnT, :lnr, :lum]\nstructure_equations = [Evolution.equationHSE, Evolution.equationT,\n                       Evolution.equationContinuity, Evolution.equationLuminosity]\nremesh_split_functions = [StellarModels.split_lnr_lnρ, StellarModels.split_lum,\n                          StellarModels.split_lnT, StellarModels.split_xa]\nnet = NuclearNetwork([:H1,:He4,:C12, :N14, :O16], [(:kipp_rates, :kipp_pp), (:kipp_rates, :kipp_cno)])\nnz = 1000\nnextra = 100\neos = EOS.IdealEOS(false)\nopacity = Opacity.SimpleElectronScatteringOpacity()\nsm = StellarModel(varnames, structure_equations, nz, nextra,\n                  remesh_split_functions, net, eos, opacity);\nnothing #hide","category":"page"},{"location":"NuclearBurning/#Initialize-StellarModel-and-evaluate-equations-and-jacobian","page":"NuclearBurning.jl","title":"Initialize StellarModel and evaluate equations and jacobian","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We do not have a working initial condition yet. We require pressure, temperature profiles. One simple available initial condition is that of an n=1 polytrope. This sets the pressure and density and computes the temperature from the EOS. The luminosity is initialized by assuming pure radiative transport for the temperature gradient produced by the polytrope.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"The normal evolution loop will store the information at the end of the step into an attribute of type StellarStepInfo, stored at sm.esi (end step info). After initializing our polytrope we can mimic that behavior by calling set_end_step_info!(sm). We then 'cycle' this info into the information of a hypothetical previous step with cycle_step_info, so now sm.psi contains our initial condition. Finally we call set_start_step_info to use sm.psi (previous step info) to populate the information needed before the Newton solver in sm.ssi (start step info). At last we are in position to evaluate the equations and compute the Jacobian.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"n=3\nStellarModels.n_polytrope_initial_condition!(n, sm, MSUN, 100 * RSUN; initial_dt=10 * SECYEAR)\nEvolution.set_step_info!(sm, sm.esi)\nEvolution.cycle_step_info!(sm);\nEvolution.set_step_info!(sm, sm.ssi)","category":"page"},{"location":"NuclearBurning/#Benchmarking","page":"NuclearBurning.jl","title":"Benchmarking","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"The previous code leaves everything ready to solve the linearized system. For now we make use of a the serial Thomas algorithm for tridiagonal block matrices. We first show how long it takes to evaluate the Jacobian matrix. This requires two steps, the first is to evaluate properties across the model (for example, the EOS) and then evaluate all differential equations.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"@benchmark begin\n    StellarModels.update_stellar_model_properties!(sm, sm.props)\n    Evolution.eval_jacobian_eqs!(sm)\nend","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"To get an idea of how much a complete iteration of the solver takes, we need to benchmark both the calculation of the Jacobian and the matrix solver. This is because the matrix solver is destructive, as it uses the allocated Jacobian to store intermediate results. The time it takes to run only the matrix solver can be determined by substracting the previous benchmark from this one.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"@benchmark begin\n    StellarModels.update_stellar_model_properties!(sm, sm.props)\n    Evolution.eval_jacobian_eqs!($sm)\n    Evolution.thomas_algorithm!($sm)\nend","category":"page"},{"location":"NuclearBurning/#Evolving-our-model","page":"NuclearBurning.jl","title":"Evolving our model","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We can now evolve our star! We will initiate a 1M_odot star with a radius of 100R_odot using an n=1 polytrope (it would be much better to use n=3 or n=3/2 polytropes, for now I only use this because there is a simple analytical solution). The star is expected to contract until it ignites hydrogen. We set a few options for the simulation with a toml file, which we generate dynamically. These simulation should complete in about a thousand steps once it reaches the max_center_T limit.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Output is stored in HDF5 files, and easy to use functions are provided with the Evolution module to turn these HDF5 files into DataFrame objects. HDF5 output is compressed by default.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"open(\"example_options.toml\", \"w\") do file\n    write(file,\n          \"\"\"\n          [remesh]\n          do_remesh = true\n\n          [solver]\n          newton_max_iter_first_step = 1000\n          newton_max_iter = 200\n\n          [timestep]\n          dt_max_increase = 10.0\n          delta_R_limit = 0.01\n          delta_Tc_limit = 0.01\n\n          [termination]\n          max_model_number = 2000\n          max_center_T = 4e7\n\n          [plotting]\n          do_plotting = false\n          wait_at_termination = false\n          plotting_interval = 1\n\n          window_specs = [\"HR\", \"profile\", \"history\"]\n          window_layouts = [[1, 1],  # arrangement of plots\n                            [2, 1],\n                            [3, 1]\n                            ]\n\n          profile_xaxis = 'mass'\n          profile_yaxes = ['log10_T']\n          profile_alt_yaxes = ['X','Y']\n\n          history_xaxis = 'star_age'\n          history_yaxes = ['R_surf']\n          history_alt_yaxes = ['T_center']\n\n          [io]\n          profile_interval = 50\n          terminal_header_interval = 100\n          terminal_info_interval = 100\n\n          \"\"\")\nend\nStellarModels.set_options!(sm.opt, \"./example_options.toml\")\nrm(sm.opt.io.hdf5_history_filename; force=true)\nrm(sm.opt.io.hdf5_profile_filename; force=true)\nStellarModels.n_polytrope_initial_condition!(n, sm, 1*MSUN, 100 * RSUN; initial_dt=1000 * SECYEAR)\n@time Evolution.do_evolution_loop!(sm);\nnothing #hide","category":"page"},{"location":"NuclearBurning/#Plotting-with-Makie","page":"NuclearBurning.jl","title":"Plotting with Makie","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Now that our simulation is complete we can analyze the results. We make use of the Makie package for this. I'm not a fan of the Makie defaults, so I adjust them. I normally also adjust the fonts to be consistent with \\LaTeX, but I avoid that here so we don't need to distribute those fonts together with Jems.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"using CairoMakie, LaTeXStrings, MathTeXEngine\nbasic_theme = Theme(fonts=(regular=texfont(:text), bold=texfont(:bold),\n                           italic=texfont(:italic), bold_italic=texfont(:bolditalic)),\n                    fontsize=30, size=(1000, 750), linewidth=7,\n                    Axis=(xlabelsize=40, ylabelsize=40, titlesize=40, xgridvisible=false, ygridvisible=false,\n                          spinewidth=2.5, xminorticksvisible=true, yminorticksvisible=true, xtickalign=1, ytickalign=1,\n                          xminortickalign=1, yminortickalign=1, xticksize=14, xtickwidth=2.5, yticksize=14,\n                          ytickwidth=2.5, xminorticksize=7, xminortickwidth=2.5, yminorticksize=7, yminortickwidth=2.5,\n                          xticklabelsize=35, yticklabelsize=35, xticksmirrored=true, yticksmirrored=true),\n                    Legend=(patchsize=(70, 10), framevisible=false, patchlabelgap=20, rowgap=10))\nset_theme!(basic_theme)","category":"page"},{"location":"NuclearBurning/#Compare-against-polytropes","page":"NuclearBurning.jl","title":"Compare against polytropes","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Below we see how the profile of the star compares to different polytropes. We make use of the facility tools to obtain DataFrame objects out of the hdf5 output. In particular, get_profile_names_from_hdf5 will provide the names of all profiles contained within the hdf5 file, while get_profile_dataframe_from_hdf5 is used to obtain one DataFrame corresponding to one stellar profile. The animation is constructed using the Observable type that makie provides. Note that the zero points of the polytropes are arbitrary.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"profile_names = StellarModels.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nf = Figure();\nax = Axis(f[1, 1]; xlabel=L\"\\log_{10}(\\rho/\\mathrm{[g\\;cm^{-3}]})\", ylabel=L\"\\log_{10}(P/\\mathrm{[dyn]})\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(StellarModels.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\n#To see why this is done this way, see https://docs.makie.org/stable/explanations/nodes/index.html#problems_with_synchronous_updates\n#the main issue is that remeshing changes the size of the arrays\nlog10_ρ = @lift($profile[!, \"log10_ρ\"])\nlog10_P = Observable(rand(length(log10_ρ.val)))\n\nprofile_line = lines!(ax, log10_ρ, log10_P; label=\"real profile\")\nxvals = LinRange(-13, 4, 100)\nlines!(ax, xvals, (1 + 1 / 1) .* xvals .+ 20; label=\"n=1\")\nlines!(ax, xvals, (1 + 1 / (1.5)) .* xvals .+ 15; label=\"n=1.5\")\nlines!(ax, xvals, (1 + 1 / 3) .* xvals .+ 15; label=\"n=3\")\naxislegend(ax; position=:rb)\n\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\nprofile_text = text!(ax, -10, 20; text=model_number_str)\n\nrecord(f, \"rho_P_evolution.gif\", profile_names[1:end]; framerate=2) do profile_name\n    profile = StellarModels.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", profile_name)\n    log10_P.val = profile[!, \"log10_P\"]\n    pname[] = profile_name\nend","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"(Image: Movie polytrope)","category":"page"},{"location":"NuclearBurning/#Check-nuclear-burning","page":"NuclearBurning.jl","title":"Check nuclear burning","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We see that the structure evolves towards an n=3 polytrope. Deviations near the core are due to the non-homogeneous composition as hydrogen is burnt. We can similarly visualize how the hydrogen mass fraction changes in the simulation. In here, only one frame shows the hydrogen that was burnt. To better visualize that you can adjust profile_interval in the IO options (and probably adjust the framerate).","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"profile_names = StellarModels.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nf = Figure();\nax = Axis(f[1, 1]; xlabel=L\"\\mathrm{Mass}\\;[M_\\odot]\", ylabel=L\"X\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(StellarModels.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\nmass = @lift($profile[!, \"mass\"])\nX = Observable(rand(length(mass.val)))\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\n\nprofile_line = lines!(ax, mass, X; label=\"real profile\")\nprofile_text = text!(ax, 0.7, 0.0; text=model_number_str)\n\nrecord(f, \"X_evolution.gif\", profile_names[1:end]; framerate=2) do profile_name\n    profile = StellarModels.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", profile_name)\n    X.val = profile[!, \"X\"]\n    pname[] = profile_name\nend","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"(Image: Movie polytrope)","category":"page"},{"location":"NuclearBurning/#Plot-a-funny-HR-diagram","page":"NuclearBurning.jl","title":"Plot a funny HR diagram","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Finally, we can also access the history data of the simulation. We use this to plot a simple HR diagram. As our microphysics are very simplistic, and the initial condition is not very physical, this looks a bit funny!","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"f = Figure();\nax = Axis(f[1, 1]; xlabel=L\"\\log_{10}(T_\\mathrm{eff}/[K])\", ylabel=L\"\\log_{10}(L/L_\\odot)\", xreversed=true)\nhistory = StellarModels.get_history_dataframe_from_hdf5(\"history.hdf5\")\nlines!(ax, log10.(history[!, \"T_surf\"]), log10.(history[!, \"L_surf\"]))\nf","category":"page"},{"location":"NuclearBurning/#Perform-some-cleanup","page":"NuclearBurning.jl","title":"Perform some cleanup","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Internally we want to prevent storing any of the hdf5 files into our git repos, so I remove them. You can also take advantage of julia as a scripting language to post-process your simulation output in a similar way.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"rm(\"history.hdf5\")\nrm(\"profiles.hdf5\")\nrm(\"example_options.toml\")","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Jems.jl","page":"Home","title":"Jems.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Jems","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Jems.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jems is a package designed for performing stellar structure and evolution calculations. Its main module is Evolution where a stellar model can be evolved according to user-defined equations. On the other hand, all the other modules can be used independently through their public interfaces.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jems contains the following modules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"Chem.md\",\n    \"Constants.md\",\n    \"EOS.md\",\n    \"StellarModels.md\",\n    \"Evolution.md\",\n    \"Opacity.md\",\n]","category":"page"}]
}
