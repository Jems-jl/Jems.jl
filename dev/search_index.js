var documenterSearchIndex = {"docs":
[{"location":"Opacity/#Opacity","page":"Opacity","title":"Opacity","text":"","category":"section"},{"location":"Opacity/","page":"Opacity","title":"Opacity","text":"The Opacity module of Jems handles all things related to the opacity of stellar matter.","category":"page"},{"location":"Opacity/","page":"Opacity","title":"Opacity","text":"Modules = [Jems.Opacity]","category":"page"},{"location":"Opacity/#Jems.Opacity.get_opacity_resultsTP-Union{Tuple{TT}, Tuple{Jems.Opacity.SimpleElectronScatteringOpacity, TT, TT, AbstractVector{<:TT}, Vector{Symbol}}} where TT<:Real","page":"Opacity","title":"Jems.Opacity.get_opacity_resultsTP","text":"get_opacity_resultsTP(opacity::SimpleElectronScatteringOpacity, lnT::TT, lnP::TT, xa::Vector{<:TT},\n                        species::Vector{Symbol})::TT where {TT<:Real}\n\nEvaluates the opacity of the current mixture with mass fractions xa, species symbols species (both these should be of length nspecies), the natural log of temperature and pressure lnT, lnP, and the opacity law opacity.\n\n\n\n\n\n","category":"method"},{"location":"style/#Style-Guide","page":"Style Guide","title":"Style Guide","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"When developing Jems, please take into account the following style pointers.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"We use 4 spaces as the indent marker, and use a line length of 120. This is not strictly enforced, but try to keep overrunning lines to a minimum.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Docstrings are demarked by three double quotes:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    my_func(a::Number)\n\nThis function does something cool with number `a`.\n\"\"\"","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Comments are marked with the hashtag and a space:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"# this loop does good stuff!\nfor i = 1:10\n    a += 1\nend","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Inline comments should be separated by at least two spaces:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"c = a + b  # this is high level stuff!","category":"page"},{"location":"style/#JuliaFormatter","page":"Style Guide","title":"JuliaFormatter","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The file .JuliaFormatter.toml is be used in conjunction with JuliaFormatter.jl to automatically format source files according to our adopted style:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"JuliaFormatter.format(\".\")  # formats the whole directory of source files","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The main function of the formatter is that it will automatically fold long lines, and inserts spaces around operators. One disadvantance is that it ignores comments and does not yet handle docstrings (even if the .toml file explicitly says to include docstrings, this is a bug).","category":"page"},{"location":"Evolution/#Evolution","page":"Evolution","title":"Evolution","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"The Evolution module of Jems contains the basic tools needed to combine all other modules to perform stellar evolution. It allows a fully customizable definition of the equations that are solved together with their boundary conditions.","category":"page"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"A model is initialized by specifying its independent variables and equations. The following creates a model with a basic ideal gas EOS and electron scattering opacity, which is then initialized using an n=1 polytrope of 1M_odot and 100R_odot. Options for a simulation can be specified with a toml file. Below we directly create a file with custom options and then load it up into the model. After setting everything up the simulation is run.","category":"page"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"using Jems.Evolution\nusing Jems.EOS\nusing Jems.Opacity\nusing Jems.Constants\n\nnvars = 6\nnspecies = 2\nvarnames = [:lnP, :lnT, :lnr, :lum, :H1, :He4]\nstructure_equations=[Evolution.equationHSE, Evolution.equationT,\n                        Evolution.equationContinuity, Evolution.equationLuminosity,\n                        Evolution.equationH1, Evolution.equationHe4]\nnz = 1000\neos = EOS.IdealEOS(false)\nopacity = Opacity.SimpleElectronScatteringOpacity()\nsm = StellarModel(varnames, structure_equations, nvars, nspecies, nz, eos, opacity)\n\n#Initialize the model as n=1 polytrope with an initial timestep of 10 years\nEvolution.n1_polytrope_initial_condition(sm, MSUN, 100*RSUN; initial_dt=10*SECYEAR)\n\n#Load custom options\nopen(\"options.toml\",\"w\") do file\n    write(file,\"\"\"\n            [termination]\n            max_model_number = 300\n\"\"\")\nend\nEvolution.set_options!(sm.opt, \"options.toml\")\n\n#run simulation\n#Evolution.do_evolution_loop(sm)","category":"page"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"The results of the simulation are provided in HDF5 format.","category":"page"},{"location":"Evolution/#StellarModel.jl","page":"Evolution","title":"StellarModel.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/StellarModel.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.StellarModel","page":"Evolution","title":"Jems.Evolution.StellarModel","text":"mutable struct StellarModel{T1<:Real, T2<: Real}\n\nAn evolutionary model for a star, containing information about the star's current state, as well as the independent variables of the model and its equations.\n\nThe struct has two parametric types, T1 for 'normal' numbers, T2 for dual numbers used in automatic differentiation\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.StellarModel-Tuple{Vector{Symbol}, Vector{Function}, Int64, Int64, Int64, Jems.EOS.AbstractEOS, Jems.Opacity.AbstractOpacity}","page":"Evolution","title":"Jems.Evolution.StellarModel","text":"StellarModel(varnames::Vector{Symbol}, structure_equations::Vector{Function},\n    nvars::Int, nspecies::Int, nz::Int, eos::AbstractEOS, opacity::AbstractOpacity)\n\nConstructor for a StellarModel instance, using varnames for the independent variables, functions of the structure_equations to be solved, number of independent variables nvars, number of species in the network nspecies number of zones in the model nz and an iterface to the EOS and Opacity laws.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.StellarStepInfo","page":"Evolution","title":"Jems.Evolution.StellarStepInfo","text":"mutable struct StellarStepInfo\n\nInformation used for a simulation step. A single stellar model can have three different objects of type StellarStepInfo, containing information from the previous step, information right before the Newton solver, and information after the Newton solver has completed.\n\nThe struct has one parametric type, T1 to represent 'normal' numbers. No fields here need to have dual numbers as these will not be used in automatic differentiation routines.\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.init_diff_cache!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.init_diff_cache!","text":"init_diff_cache!(sm::StellarModel, k::Int)\n\nInitializes the diffcaches to the values of the independent variables, and sets 1s in the correct spots where the dxi^k/dx_i^k entries lie.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Options.jl","page":"Evolution","title":"Options.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Options.jl\"]","category":"page"},{"location":"Evolution/#Equations.jl","page":"Evolution","title":"Equations.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Equations.jl\"]","category":"page"},{"location":"Evolution/#Solver.jl","page":"Evolution","title":"Solver.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Solver.jl\"]","category":"page"},{"location":"Evolution/#EvolutionLoop.jl","page":"Evolution","title":"EvolutionLoop.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/EvolutionLoop.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.cycle_step_info!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.cycle_step_info!","text":"cycle_step_info!(sm::StellarModel)\n\nMoves the model info of the StellarModel sm over one state: start step info -> end step info -> previous step info -> start step info\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.do_evolution_loop-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.do_evolution_loop","text":"do_evolution_loop(sm::StellarModel)\n\nPerforms the main evolutionary loop of the input StellarModel sm. It continues taking steps until one of the termination criteria is reached (defined in sm.opt.termination)\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.get_dt_next-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.get_dt_next","text":"get_dt_next(sm::StellarModel)\n\nComputes the timestep of the next evolutionary step to be taken by the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.set_end_step_info!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.set_end_step_info!","text":"set_end_step_info(sm::StellarModel)\n\nSets the end step info (sm.esi) from current state of the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.set_start_step_info!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.set_start_step_info!","text":"set_start_step_info!(sm::StellarModel)\n\nSets the start step info of the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#InitialCondition.jl","page":"Evolution","title":"InitialCondition.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/InitialCondition.jl\"]","category":"page"},{"location":"Evolution/#IO.jl","page":"Evolution","title":"IO.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/IO.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.history_get_ind_vars_edge_value-Tuple{Jems.Evolution.StellarModel, Symbol, Symbol}","page":"Evolution","title":"Jems.Evolution.history_get_ind_vars_edge_value","text":"history_get_ind_vars_edge_value(sm::StellarModel, var_symbol::Symbol, edge::Symbol)\n\nReturns the value of the independent variable var_symbol at either the surface or the center of the StellarModel sm. edge can be either :surface or :center.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.profile_get_ind_vars_value-Tuple{Jems.Evolution.StellarModel, Symbol, Int64}","page":"Evolution","title":"Jems.Evolution.profile_get_ind_vars_value","text":"profile_get_ind_vars_value(sm::StellarModel, var_symbol::Symbol, k::Int)\n\nReturns the value of the variable Symbol var_symbol at cell number k of the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Constants/#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"Constants/","page":"Constants","title":"Constants","text":"The Constants module of Jems defines a common set of physical and mathematical constants for use across the package.","category":"page"},{"location":"Constants/","page":"Constants","title":"Constants","text":"Modules = [Jems.Constants]","category":"page"},{"location":"Chem/#Chem","page":"Chem","title":"Chem","text":"","category":"section"},{"location":"Chem/","page":"Chem","title":"Chem","text":"The Chemistry module of Jems handles all things related to chemical mixtures and isotopes.","category":"page"},{"location":"Chem/","page":"Chem","title":"Chem","text":"Modules = [Jems.Chem]","category":"page"},{"location":"Chem/#Jems.Chem.Isotope","page":"Chem","title":"Jems.Chem.Isotope","text":"struct Isotope\n\nContains basic info of an isotope:\n\nZ: atomic number (# protons)\nA: mass number (# protons + neutrons)\nname: its name (eg Hydrogen)\nmass: atomic weight in amu\n\n\n\n\n\n","category":"type"},{"location":"Chem/#Jems.Chem.get_isotope_list-Tuple{}","page":"Chem","title":"Jems.Chem.get_isotope_list","text":"get_isotope_list()\n\ngets a list of all currently included isotopes.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#EOS","page":"EOS","title":"EOS","text":"","category":"section"},{"location":"EOS/","page":"EOS","title":"EOS","text":"The EOS module of Jems handles all things related to the equation of state of stellar matter.","category":"page"},{"location":"EOS/","page":"EOS","title":"EOS","text":"Modules = [Jems.EOS]","category":"page"},{"location":"EOS/#Jems.EOS.IdealEOS","page":"EOS","title":"Jems.EOS.IdealEOS","text":"struct IdealEOS <: AbstractEOS\n\nInterface of an Ideal gas equation of state\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.get_μ_IdealEOS-Union{Tuple{TT}, Tuple{AbstractVector{TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.get_μ_IdealEOS","text":"get_μ_IdealEOS(xa, species)\n\ncomputes the molecular weight of the mixture xa, given and list of species.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#Jems.EOS.set_EOS_resultsTP!-Union{Tuple{TT}, Tuple{Jems.EOS.IdealEOS, Jems.EOS.EOSResults{TT}, TT, TT, AbstractVector{TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.set_EOS_resultsTP!","text":"get_EOS_resultsTP(eos, lnT, lnP, xa, species)\n\ncomputes thermodynamical quantities of a mixture xa at temperature lnT and pressure lnP, given the ideal equation of state eos, list of species.\n\n\n\n\n\n","category":"method"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"EditURL = \"../../examples/NuclearBurning.jl\"","category":"page"},{"location":"NuclearBurning/#NuclearBurning.jl","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"This notebook provides a simple example of a star with simplified mycrophysics undergoing nuclear burning. Import all necessary Jems modules. We will also do some benchmarks, so we import BenchmarkTools as well.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"using BenchmarkTools\nusing Jems.Chem\nusing Jems.Constants\nusing Jems.EOS\nusing Jems.Opacity\nusing Jems.Evolution","category":"page"},{"location":"NuclearBurning/#Model-creation","page":"NuclearBurning.jl","title":"Model creation","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We start by creating the stellar model. In this example we consider a model with 6 independent variables, two of which correspond to composition. The independent variables here are ln(P), ln(T), ln(r), the luminosity L and the mass fractions of Hydrogen and Helium.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"The Evolution module has pre-defined equations corresponding to these variables, which we provide here. For now, only a simple (fully ionized) ideal gas law EOS is available. Similarly, only a simple simple electron scattering opacity equal to kappa=02(1+X)mathrmcm^2g^-1 is available.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"nvars = 6\nnspecies = 2\nvarnames = [:lnP, :lnT, :lnr, :lum, :H1, :He4]\nstructure_equations = [Evolution.equationHSE, Evolution.equationT, Evolution.equationContinuity,\n                       Evolution.equationLuminosity, Evolution.equationH1, Evolution.equationHe4]\nnz = 1000\neos = EOS.IdealEOS(false)\nopacity = Opacity.SimpleElectronScatteringOpacity()\nsm = StellarModel(varnames, structure_equations, nvars, nspecies, nz, eos, opacity);\nnothing #hide","category":"page"},{"location":"NuclearBurning/#Initialize-StellarModel-and-evaluate-equations-and-jacobian","page":"NuclearBurning.jl","title":"Initialize StellarModel and evaluate equations and jacobian","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We do not have a working initial condition yet. We require pressure, temperature profiles. One simple available initial condition is that of an n=1 polytrope. This sets the pressure and density and computes the temperature from the EOS. The luminosity is initialized by assuming pure radiative transport for the temperature gradient produced by the polytrope.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"The normal evolution loop will store the information at the end of the step into an attribute of type StellarStepInfo, stored at sm.esi. After initializing our polytrope we can mimic that behavior by calling set_end_step_info!(sm). TODO: more explanation.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Evolution.n1_polytrope_initial_condition(sm, MSUN, 100 * RSUN; initial_dt=10 * SECYEAR)\n\nEvolution.set_end_step_info!(sm)\nEvolution.cycle_step_info!(sm)\nEvolution.set_start_step_info!(sm)\nEvolution.eval_jacobian_eqs!(sm)","category":"page"},{"location":"NuclearBurning/#Benchmarking","page":"NuclearBurning.jl","title":"Benchmarking","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"The previous code leaves everything ready to solve the linearized system. We use the package LinearSolve for this, which provides various algorithms for linear systems defined by sparse arrays. In the future we might want to try additional solvers provided (for instance, solvers that make use of the Krylov space such as GMRES). Alternate solvers might work much better for systems with excessively large nuclear networks.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We can compute a simple benchmark of the time it takes to solve the linear system once. Each timestep will require multiple iterations of the Newton solver, so this would be a lower bound on the time that will take.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"using LinearSolve\n@benchmark begin\n    $sm.linear_solver.A = $sm.jacobian\n    $sm.linear_solver.b = $sm.eqs_numbers\n    corr = solve($sm.linear_solver)\nend","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"On my system, this takes on the order of 800 μs. Next up we can check how long it takes to compute a single row of the jacobian. With a row here I mean all the entries that correspond to one cell. The code below benchmarks the time it takes to compute the jacobian elements associated with row 2","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Benchmark one jacobian row","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"@benchmark Evolution.eval_jacobian_eqs_row!(sm, 2)","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Again on my machine, this takes sim 16mathrmmu s. This is a short amount of time, but we have a thousand cells to compute. Let's benchmark the calculation of the full jacobian.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Benchmark entire jacobian","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"@benchmark Evolution.eval_jacobian_eqs!(sm)","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"And on my computer, this took about 52mathrmms. Even though we have a thousand cells, the computation time was not a thousand times longer than computing the components of the jacobian for a single cell. The reason for this is that the calculation is parallelized so cells are done independently. However, I used 8 cores for my calculations, so the scaling is less than ideal. One of the main culprits here is the garbage collector. Current versions of julia can only perform garbage collection in a serial way, so it does not take advantage of all threads. Starting with julia 1.10, the garbage collector will be able to run in multiple threads, so that should alleviate issues with performance scaling.","category":"page"},{"location":"NuclearBurning/#Evolving-our-model","page":"NuclearBurning.jl","title":"Evolving our model","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We can now evolve our star! We will initiate a 1M_odot star with a radius of 100R_odot using an n=1 polytrope (it would be much better to use n=3 or n=3/2 polytropes, for now I only use this because there is a simple analytical solution). The star is expected to contract until it ignites hydrogen. We set a few options for the simulation with a toml file, which we generate dynamically. These simulation should complete in about a thousand steps once it reaches the max_center_T limit.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Output is stored in HDF5 files, and easy to use functions are provided with the Evolution module to turn these HDF5 files into DataFrame objects. HDF5 output is compressed by default.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"open(\"example_options.toml\", \"w\") do file\n    write(file,\n          \"\"\"\n          [solver]\n          newton_max_iter_first_step = 1000\n          newton_max_iter = 200\n\n          [timestep]\n          dt_max_increase = 2.0\n\n          [termination]\n          max_model_number = 3000\n          max_center_T = 4e7\n\n          [io]\n          profile_interval = 50\n          \"\"\")\nend\nEvolution.set_options!(sm.opt, \"./example_options.toml\")\nrm(sm.opt.io.hdf5_history_filename; force=true)\nrm(sm.opt.io.hdf5_profile_filename; force=true)\nEvolution.n1_polytrope_initial_condition(sm, MSUN, 100 * RSUN; initial_dt=1000 * SECYEAR)\n\n@time Evolution.do_evolution_loop(sm)","category":"page"},{"location":"NuclearBurning/#Plotting-with-Makie","page":"NuclearBurning.jl","title":"Plotting with Makie","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Now that our simulation is complete we can analyze the results. We make use of the Makie package for this. I'm not a fan of the Makie defaults, so I adjust them. I normally also adjust the fonts to be consistent with \\LaTeX, but I avoid that here so we don't need to distribute those fonts together with Jems.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"using CairoMakie, LaTeXStrings\nbasic_theme = Theme(\n                    #fonts = (regular = \"ComputerModernFont/cmunrm.ttf\", bold = \"ComputerModernFont/cmunbx.ttf\", italic = \"ComputerModernFont/cmunti.ttf\", bold_italic = \"ComputerModernFont/cmunbi.ttf\"), # taken from https://sourceforge.net/projects/cm-unicode/\n                    fontsize=30, resolution=(1000, 750), linewidth=7,\n                    Axis=(xlabelsize=40, ylabelsize=40, titlesize=40, xgridvisible=false, ygridvisible=false,\n                          spinewidth=2.5, xminorticksvisible=true, yminorticksvisible=true, xtickalign=1, ytickalign=1,\n                          xminortickalign=1, yminortickalign=1, xticksize=14, xtickwidth=2.5, yticksize=14,\n                          ytickwidth=2.5, xminorticksize=7, xminortickwidth=2.5, yminorticksize=7, yminortickwidth=2.5,\n                          xticklabelsize=35, yticklabelsize=35, xticksmirrored=true, yticksmirrored=true),\n                    Legend=(patchsize=(70, 10), framevisible=false, patchlabelgap=20, rowgap=10))\nset_theme!(basic_theme)","category":"page"},{"location":"NuclearBurning/#Compare-against-polytropes","page":"NuclearBurning.jl","title":"Compare against polytropes","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Below we see how the profile of the star compares to different polytropes. We make use of the facility tools to obtain DataFrame objects out of the hdf5 output. In particular, get_profile_names_from_hdf5 will provide the names of all profiles contained within the hdf5 file, while get_profile_dataframe_from_hdf5 is used to obtain one DataFrame corresponding to one stellar profile. The animation is constructed using the Observable type that makie provides. Note that the zero points of the polytropes are arbitrary.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"profile_names = Evolution.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nf = Figure()\nax = Axis(f[1, 1]; xlabel=L\"\\log_{10}(\\rho/\\mathrm{[g\\;cm^{-3}]})\", ylabel=L\"\\log_{10}(P/\\mathrm{[dyn]})\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(Evolution.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\nlog10_ρ = @lift($profile[!, \"log10_ρ\"])\nlog10_P = @lift($profile[!, \"log10_P\"])\n\nprofile_line = lines!(ax, log10_ρ, log10_P; label=\"real profile\")\nxvals = LinRange(-13, 4, 100)\nlines!(ax, xvals, (1 + 1 / 1) .* xvals .+ 20; label=\"n=1\")\nlines!(ax, xvals, (1 + 1 / (1.5)) .* xvals .+ 15; label=\"n=1.5\")\nlines!(ax, xvals, (1 + 1 / 3) .* xvals .+ 15; label=\"n=3\")\naxislegend(ax; position=:rb)\n\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\nprofile_text = text!(ax, -10, 20; text=model_number_str)\n\nrecord(f, \"rho_P_evolution.gif\", profile_names[1:end]; framerate=2) do profile_name\n    pname[] = profile_name\nend","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"(Image: Movie polytrope)","category":"page"},{"location":"NuclearBurning/#Check-nuclear-burning","page":"NuclearBurning.jl","title":"Check nuclear burning","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We see that the structure evolves towards an n=3 polytrope. Deviations near the core are due to the non-homogeneous composition as hydrogen is burnt. We can similarly visualize how the hydrogen mass fraction changes in the simulation. In here only one frame shows the hydrogen that was burnt, to better visualize that you can adjust profile_interval in the Io options (and probably adjust the framerate).","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"profile_names = Evolution.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nf = Figure()\nax = Axis(f[1, 1]; xlabel=L\"\\mathrm{Mass}\\;[M_\\odot]\", ylabel=L\"X\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(Evolution.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\nmass = @lift($profile[!, \"mass\"])\nX = @lift($profile[!, \"X\"])\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\n\nprofile_line = lines!(ax, mass, X; label=\"real profile\")\nprofile_text = text!(ax, 0.7, 0.0; text=model_number_str)\n\nrecord(f, \"X_evolution.gif\", profile_names[1:end]; framerate=2) do profile_name\n    pname[] = profile_name\nend","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"(Image: Movie polytrope)","category":"page"},{"location":"NuclearBurning/#Plot-a-funny-HR-diagram","page":"NuclearBurning.jl","title":"Plot a funny HR diagram","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Finally, we can also access the history data of the simulation. We use this to plot a simple HR diagram. As our microphysics are very simplistic, and the initial condition is not very physical, this looks a bit funny!","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"f = Figure()\nax = Axis(f[1, 1]; xlabel=L\"\\log_{10}(T_\\mathrm{eff}/[K])\", ylabel=L\"\\log_{10}(L/L_\\odot)\", xreversed=true)\nhistory = Evolution.get_history_dataframe_from_hdf5(\"history.hdf5\")\nlines!(ax, log10.(history[!, \"T_surf\"]), log10.(history[!, \"L_surf\"]))\nf","category":"page"},{"location":"NuclearBurning/#Perform-some-cleanup","page":"NuclearBurning.jl","title":"Perform some cleanup","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Internally we want to prevent storing any of the hdf5 files into our git repos, so I remove them. You can also take advantage of julia as a scripting language to post-process your simulation output in a similar way.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"rm(\"history.hdf5\")\nrm(\"profiles.hdf5\")\nrm(\"example_options.toml\")","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Jems.jl","page":"Home","title":"Jems.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Jems","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Jems.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jems is a package designed for performing stellar structure and evolution calculations. Its main module is Evolution where a stellar model can be initialized and evolved according to user-defined equations. On the other hand, all the other modules can be used independently through their public interfaces.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jems contains the following modules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"Chem.md\",\n    \"Constants.md\",\n    \"EOS.md\",\n    \"Evolution.md\",\n    \"Opacity.md\",\n]","category":"page"}]
}
