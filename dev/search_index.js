var documenterSearchIndex = {"docs":
[{"location":"Opacity/#Opacity","page":"Opacity","title":"Opacity","text":"","category":"section"},{"location":"Opacity/","page":"Opacity","title":"Opacity","text":"The Opacity module of Jems handles all things related to the opacity of stellar matter.","category":"page"},{"location":"Opacity/","page":"Opacity","title":"Opacity","text":"Modules = [Jems.Opacity]","category":"page"},{"location":"Opacity/#Jems.Opacity.get_opacity_resultsTP-Union{Tuple{TT}, Tuple{Jems.Opacity.SimpleElectronScatteringOpacity, Dict{Symbol, Jems.Chem.Isotope}, TT, TT, Vector{<:TT}, Vector{Symbol}}} where TT<:Real","page":"Opacity","title":"Jems.Opacity.get_opacity_resultsTP","text":"get_opacity_resultsTP(opacity::SimpleElectronScatteringOpacity, isotope_data::Dict{Symbol, Isotope},\n    lnT::TT, lnP::TT, xa::Vector{<:TT}, species::Vector{Symbol})::TT where{TT<:Real}\n\nEvaluates the opacity of the current mixture with mass fractions xa, species symbols species (both these should be of length nspecies), the natural log of temperature and pressure lnT, lnP, the  opacity law opacity and the isotope_data dictionary.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Evolution","page":"Evolution","title":"Evolution","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"The Evolution module of Jems contains the basic tools needed to combine all other modules to perform stellar evolution. It allows a fully customizable definition of the equations that are solved together with their boundary conditions.","category":"page"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"A model is initialized by specifying its independent variables and equations. The following creates a model with a basic ideal gas EOS and electron scattering opacity, which is then initialized using an n=1 polytrope of 1M_odot and 100R_odot. Options for a simulation can be specified with a toml file. Below we directly create a file with custom options and then load it up into the model. After setting everything up the simulation is run.","category":"page"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"using Jems.Evolution\nusing Jems.EOS\nusing Jems.Opacity\nusing Jems.Constants\n\nnvars = 6\nnspecies = 2\nvarnames = [:lnP, :lnT, :lnr, :lum, :H1, :He4]\nstructure_equations=[Evolution.equationHSE, Evolution.equationT,\n                        Evolution.equationContinuity, Evolution.equationLuminosity,\n                        Evolution.equationH1, Evolution.equationHe4]\nnz = 1000\neos = EOS.IdealEOS(false)\nopacity = Opacity.SimpleElectronScatteringOpacity()\nsm = StellarModel(varnames, structure_equations, nvars, nspecies, nz, eos, opacity)\n\n#Initialize the model as n=1 polytrope with an initial timestep of 10 years\nEvolution.n1_polytrope_initial_condition(sm, MSUN, 100*RSUN; initial_dt=10*SECYEAR)\n\n#Load custom options\nopen(\"options.toml\",\"w\") do file\n    write(file,\"\"\"\n            [termination]\n            max_model_number = 300\n\"\"\")\nend\nEvolution.set_options!(sm.opt, \"options.toml\")\n\n#run simulation\n#Evolution.do_evolution_loop(sm)","category":"page"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"The results of the simulation are provided in HDF5 format.","category":"page"},{"location":"Evolution/#StellarModel.jl","page":"Evolution","title":"StellarModel.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/StellarModel.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.StellarModel","page":"Evolution","title":"Jems.Evolution.StellarModel","text":"mutable struct StellarModel\n\nAn evolutionary model for a star, containing information about the star's current state, as well as the independent  variables of the model and its equations.\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.StellarModel-Tuple{Vector{Symbol}, Vector{Function}, Int64, Int64, Int64, Jems.EOS.AbstractEOS, Jems.Opacity.AbstractOpacity}","page":"Evolution","title":"Jems.Evolution.StellarModel","text":"StellarModel(varnames::Vector{Symbol}, structure_equations::Vector{Function}, nvars::Int, \nnspecies::Int, nz::Int, eos::AbstractEOS, opacity::AbstractOpacity)\n\nConstructor for a StellarModel instance, using varnames for the independent variables, functions of the  structure_equations to be solved, number of independent variables nvars, number of species in the network nspecies number of zones in the model nz and an iterface to the EOS and Opacity laws.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.StellarStepInfo","page":"Evolution","title":"Jems.Evolution.StellarStepInfo","text":"mutable struct StellarStepInfo\n\nInformation used for a simulation step. A single stellar model can have three different objects of type StellarStepInfo, containing information from the previous step, information right before the Newton solver, and information after the Newton solver has completed.\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Options.jl","page":"Evolution","title":"Options.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Options.jl\"]","category":"page"},{"location":"Evolution/#Equations.jl","page":"Evolution","title":"Equations.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Equations.jl\"]","category":"page"},{"location":"Evolution/#Solver.jl","page":"Evolution","title":"Solver.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Solver.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.eval_cell_eqs-Union{Tuple{TT}, Tuple{Jems.Evolution.StellarModel, Int64, Vector{<:TT}}} where TT<:Real","page":"Evolution","title":"Jems.Evolution.eval_cell_eqs","text":"eval_cell_eqs(sm::StellarModel, k::Int, ind_vars_view::Vector{<:TT}) where{TT<:Real}\n\nEvaluates the stellar structure equations of the stellar model, sm, at cell k, given the view of the independent variables, ind_vars_view.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.eval_eqs!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.eval_eqs!","text":"eval_eqs(sm::StellarModel)\n\nEvaluates the stellar structure equations of the stellar model, sm, for all cells.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.eval_jacobian!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.eval_jacobian!","text":"eval_jacobian!(sm::StellarModel)\n\nEvaluates the whole Jacobian matrix of the given StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.eval_jacobian_row!-Tuple{Jems.Evolution.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.eval_jacobian_row!","text":"eval_jacobian_row!(sm::StellarModel, k::int)\n\nEvaluates row k of the Jacobian matrix of the given StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#EvolutionLoop.jl","page":"Evolution","title":"EvolutionLoop.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/EvolutionLoop.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.cycle_step_info!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.cycle_step_info!","text":"cycle_step_info!(sm::StellarModel)\n\nMoves the model info of the StellarModel sm over one state: start step info -> end step info -> previous step info -> start step info\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.do_evolution_loop-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.do_evolution_loop","text":"do_evolution_loop(sm::StellarModel)\n\nPerforms the main evolutionary loop of the input StellarModel sm. It continues taking steps until one of the termination criteria is reached (defined in sm.opt.termination)\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.get_dt_next-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.get_dt_next","text":"get_dt_next(sm::StellarModel)\n\nComputes the timestep of the next evolutionary step to be taken by the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.set_end_step_info!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.set_end_step_info!","text":"set_end_step_info(sm::StellarModel)\n\nSets the end step info (sm.esi) from current state of the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.set_start_step_info!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.set_start_step_info!","text":"set_start_step_info!(sm::StellarModel)\n\nSets the start step info of the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#InitialCondition.jl","page":"Evolution","title":"InitialCondition.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/InitialCondition.jl\"]","category":"page"},{"location":"Evolution/#IO.jl","page":"Evolution","title":"IO.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/IO.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.history_get_ind_vars_edge_value-Tuple{Jems.Evolution.StellarModel, Symbol, Symbol}","page":"Evolution","title":"Jems.Evolution.history_get_ind_vars_edge_value","text":"history_get_ind_vars_edge_value(sm::StellarModel, var_symbol::Symbol, edge::Symbol)\n\nReturns the value of the independent variable var_symbol at either the surface or the center of the StellarModel sm. edge can be either :surface or :center.    \n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.profile_get_ind_vars_value-Tuple{Jems.Evolution.StellarModel, Symbol, Int64}","page":"Evolution","title":"Jems.Evolution.profile_get_ind_vars_value","text":"profile_get_ind_vars_value(sm::StellarModel, var_symbol::Symbol, k::Int)\n\nReturns the value of the variable Symbol var_symbol at cell number k of the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Constants/#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"Constants/","page":"Constants","title":"Constants","text":"The Constants module of Jems defines a common set of physical and mathematical constants for use across the package.","category":"page"},{"location":"Constants/","page":"Constants","title":"Constants","text":"Modules = [Jems.Constants]","category":"page"},{"location":"Chem/#Chem","page":"Chem","title":"Chem","text":"","category":"section"},{"location":"Chem/","page":"Chem","title":"Chem","text":"The Chemistry module of Jems handles all things related to chemical mixtures and isotopes.","category":"page"},{"location":"Chem/","page":"Chem","title":"Chem","text":"Modules = [Jems.Chem]","category":"page"},{"location":"Chem/#Jems.Chem.Isotope","page":"Chem","title":"Jems.Chem.Isotope","text":"struct Isotope\n\nContains basic info of an isotope:\n\nZ: atomic number (# protons)\nA: mass number (# protons + neutrons)\nname: its name (eg Hydrogen)\nmass: atomic weight in amu\n\n\n\n\n\n","category":"type"},{"location":"Chem/#Jems.Chem.get_isotope_list-Tuple{}","page":"Chem","title":"Jems.Chem.get_isotope_list","text":"get_isotope_list()\n\ngets a list of all currently included isotopes.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#EOS","page":"EOS","title":"EOS","text":"","category":"section"},{"location":"EOS/","page":"EOS","title":"EOS","text":"The EOS module of Jems handles all things related to the equation of state of stellar matter.","category":"page"},{"location":"EOS/","page":"EOS","title":"EOS","text":"Modules = [Jems.EOS]","category":"page"},{"location":"EOS/#Jems.EOS.IdealEOS","page":"EOS","title":"Jems.EOS.IdealEOS","text":"struct IdealEOS <: AbstractEOS\n\nInterface of an Ideal gas equation of state\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.get_EOS_resultsTP-Union{Tuple{TT}, Tuple{Jems.EOS.IdealEOS, Dict{Symbol, Jems.Chem.Isotope}, TT, TT, Vector{<:TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.get_EOS_resultsTP","text":"get_EOS_resultsTP(eos, isotope_data, lnT, lnP, xa, species)\n\ncomputes thermodynamical quantities of a mixture xa at temperature lnT and pressure lnP, given the ideal equation of state eos, isotope_data and list of species.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#Jems.EOS.get_μ_IdealEOS-Union{Tuple{TT}, Tuple{Dict{Symbol, Jems.Chem.Isotope}, Vector{<:TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.get_μ_IdealEOS","text":"get_μ_IdealEOS(isotope_data, xa, species)\n\ncomputes the molecular weight of the mixture xa, given the isotope_data and list of species\n\n\n\n\n\n","category":"method"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"EditURL = \"../../examples/NuclearBurning.jl\"","category":"page"},{"location":"NuclearBurning/#NuclearBurning.jl","page":"Examples","title":"NuclearBurning.jl","text":"","category":"section"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"This notebook provides a simple example of a star with simplified mycrophysics undergoing nuclear burning.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"Import all necessary Jems modules. We will also do some benchmarks, so we import BenchmarkTools as well","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"using BenchmarkTools\nusing Jems.Chem\nusing Jems.Constants\nusing Jems.EOS\nusing Jems.Opacity\nusing Jems.Evolution","category":"page"},{"location":"NuclearBurning/#Model-creation","page":"Examples","title":"Model creation","text":"","category":"section"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"We start by creating the stellar model. In this example we consider a model with 6 independent variables, two of which correspond to composition. The independent variables here are ln(P), ln(T), ln(r), the luminosity L and the mass fractions of Hydrogen and Helium.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"The Evolution module has pre-defined equations corresponding to these variables, which we provide here.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"For now, only a simple (fully ionized) ideal gas law EOS is available. Similarly, only a simple simple electron scattering opacity equal to kappa=02(1+X)mathrmcm^2g^-1 is available.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Create a StellarModel\nnvars = 6\nnspecies = 2\nvarnames = [:lnP,:lnT,:lnr,:lum,:H1, :He4]\nstructure_equations=[Evolution.equationHSE, Evolution.equationT,\n                        Evolution.equationContinuity, Evolution.equationLuminosity,\n                        Evolution.equationH1, Evolution.equationHe4]\nnz = 1000\neos = EOS.IdealEOS(false)\nopacity = Opacity.SimpleElectronScatteringOpacity()\nsm = StellarModel(varnames, structure_equations, nvars, nspecies, nz, eos, opacity);\nnothing #hide","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"This will not create a working initial condition. One simple available initial condition is that of an n=1 polytrope. This determines the pressure and density profile, with the temperature being derived from the EOS. The luminosity is initialized by assuming pure radiative transport for the temperature gradient produced by the polytrope.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"The normal evolution loop will store the information at the end of the step into an attribute of type StellarStepInfo, stored at sm.esi. After initializing our polytrope we can mimic that behavior by calling set_end_step_info!(sm). TODO: more explanation.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Initialize StellarModel and evaluate equations and jacobian\nEvolution.n1_polytrope_initial_condition(sm, MSUN, 100*RSUN; initial_dt=10*SECYEAR)\n\nEvolution.set_end_step_info!(sm)\nEvolution.cycle_step_info!(sm)\nEvolution.set_start_step_info!(sm)\n\nEvolution.eval_jacobian!(sm)\nEvolution.eval_eqs!(sm)","category":"page"},{"location":"NuclearBurning/#Benchmarking","page":"Examples","title":"Benchmarking","text":"","category":"section"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"The previous code leaves everything ready to solve the linearized system. We use the package LinearSolve for this, which provides various algorithms for linear systems defined by sparse arrays. In the future we might want to try additional solvers provided (for instance, solvers that make use of the Krylov space such as GMRES). Alternate solvers might work much better for systems with excessively large nuclear networks.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"We can compute a simple benchmark of the time it takes to solve the linear system once. Each timestep will require multiple iterations of the Newton solver, so this would be a lower bound on the time that will take.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Benchmark linear solver\nusing LinearSolve\n@benchmark begin\n    $sm.linear_solver.A = $sm.jacobian\n    $sm.linear_solver.b = $sm.eqs\n    corr =solve($sm.linear_solver)\nend","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"In my system, this takes on the order of 4.3 ms. Next up we can check how long it takes to compute a single row of the jacobian. With a row here I mean all the entries that correspond to one cell. The code below benchmarks the time it takes to compute the jacobian elements associated with row 2","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Benchmark one jacobian row\n@benchmark Evolution.eval_jacobian_row!(sm,2)","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"Again on my machine, this takes sim 16mathrmmu s. This is a short amount of time, but we have a thousand cells to compute. Let's benchmark the calculation of the full jacobian.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Benchmark entire jacobian\n@benchmark Evolution.eval_jacobian!(sm)","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"And in my computer, this took about 52mathrmms. Even though we have a thousand cells, the computation time was not a thousand times longer than computing the components of the jacobian for a single cell. The reason for this is that the calculation is parallelized so cells are done independently. However, I used 8 cores in my calculation, so the scaling is less than ideal. One of the main culprits here is the garbage collector. Current versions of julia can only perform garbage collection in a serial way, so it does not take advantage of all threads. Starting with julia 1.10, the garbage collector will be able to run in multiple threads, so that should alleviate issues with performance scaling.","category":"page"},{"location":"NuclearBurning/#Evolving-our-model","page":"Examples","title":"Evolving our model","text":"","category":"section"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"We can now evolve our star! We will initiate a 1M_odot star with a radius of 100\\odot$ using an n=1 polytrope (it would be much better to use n=3 or n=3/2 polytropes, for now I only use this because there is a simple analytical solution). The star is expected to contract until it ignites hydrogen. We set a few options for the simulation with a toml file, which we generate dynamically. These simulation should complete in about a thousand steps once it reaches the `maxcenter_T` limit.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"Output is stored in HDF5 files, and easy to use functions are provided with the Evolution module to turn these HDF5 files into DataFrame objects. HDF5 output is compressed by default.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Perform a simulation\nopen(\"example_options.toml\",\"w\") do file\n    write(file,\"\"\"\n        [solver]\n        newton_max_iter_first_step = 1000\n        newton_max_iter = 200\n\n        [timestep]\n        dt_max_increase = 2.0\n\n        [termination]\n        max_model_number = 3000\n        max_center_T = 4e7\n\n        [io]\n        profile_interval = 50\n    \"\"\")\nend\nEvolution.set_options!(sm.opt, \"./example_options.toml\")\nrm(sm.opt.io.hdf5_history_filename, force=true)\nrm(sm.opt.io.hdf5_profile_filename, force=true)\nEvolution.n1_polytrope_initial_condition(sm, MSUN, 100*RSUN, initial_dt=1000*SECYEAR)\n\n@time Evolution.do_evolution_loop(sm)","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"Now that our simulation is complete we can analyze the results. We make use of the Makie package for this. I'm not a fan of the Makie defaults, so I adjust them. I normally also adjust the fonts to be consistent with LaTeX, but I avoid that here so we don't need to distribute those fonts together with Jems.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Setup theming for Makie\nusing CairoMakie, LaTeXStrings\nbasic_theme = Theme(#fonts = (; regular = \"ComputerModernFont/cmunrm.ttf\", bold = \"ComputerModernFont/cmunbx.ttf\", italic = \"ComputerModernFont/cmunti.ttf\",bold_italic = \"ComputerModernFont/cmunbi.ttf\"), # taken from https://sourceforge.net/projects/cm-unicode/\n                fontsize=30, resolution=(1000, 750), linewidth=7,\n                Axis = (xlabelsize = 40,ylabelsize = 40, titlesize=40, xgridvisible = false, ygridvisible = false,\n                spinewidth = 2.5, xminorticksvisible = true, yminorticksvisible = true,\n                xtickalign=1,ytickalign=1,xminortickalign=1,yminortickalign=1,\n                xticksize = 14, xtickwidth = 2.5, yticksize = 14, ytickwidth = 2.5,\n                xminorticksize = 7, xminortickwidth = 2.5, yminorticksize = 7, yminortickwidth = 2.5,\n                xticklabelsize = 35, yticklabelsize = 35, xticksmirrored = true, yticksmirrored = true),\n                Legend = (patchsize = (70,10), framevisible = false, patchlabelgap=20, rowgap = 10))\nset_theme!(basic_theme)","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"Below we see how the profile of the star compares to different polytropes. We make use of the facility tools to obtain DataFrame objects out of the hdf5 output. In particular, get_profile_names_from_hdf5 will provide the names of all profiles contained within the hdf5 file, while get_profile_dataframe_from_hdf5 is used to obtain one DataFrame corresponding to one stellar profile. The animation is constructed using the Observable type that makie provides. Note that the zero points of the polytropes are arbitrary.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Compare against polytropes\nprofile_names = Evolution.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nf = Figure()\nax = Axis(f[1,1], xlabel=L\"\\log_{10}(\\mathrm{\\rho/[g\\;cm^{-3}]})\", ylabel=L\"\\log_{10}(P/\\mathrm{dyne]})\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(Evolution.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\nlog10_ρ = @lift($profile[!,\"log10_ρ\"])\nlog10_P = @lift($profile[!,\"log10_P\"])\n\nprofile_line = lines!(ax, log10_ρ, log10_P, label=\"real profile\")\nxvals = LinRange(-13,4,100)\nlines!(ax,xvals,(1+1/1) .* xvals .+ 20, label=\"n=1\")\nlines!(ax,xvals,(1+1/(1.5)) .* xvals .+ 15, label=\"n=1.5\")\nlines!(ax,xvals,(1+1/3) .* xvals .+ 15, label=\"n=3\")\naxislegend(ax, position=:rb)\n\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\nprofile_text = text!(ax, -10,20,text=model_number_str)\n\nrecord(f, \"rho_P_evolution.gif\", profile_names[1:end];\n        framerate = 2) do profile_name\n    pname[] = profile_name\nend","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"(Image: Movie polytrope) We see that the structure evolves towards an n=3 polytrope. Deviations near the core are due to the non-homogeneous composition as hydrogen is burnt. We can similarly visualize how the hydrogen mass fraction changes in the simulation. In here only one frame shows the hydrogen that was burnt, to better visualize that you can adjust profile_interval in the [io] options (and probably adjust the framerate).","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Check nuclear burning\nprofile_names = Evolution.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nusing CairoMakie\n\nf = Figure()\nax = Axis(f[1,1], xlabel=L\"\\mathrm{Mass}\\;[M_\\odot]\", ylabel=L\"X\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(Evolution.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\nmass = @lift($profile[!,\"mass\"])\nX = @lift($profile[!,\"X\"])\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\n\nprofile_line = lines!(ax, mass, X, label=\"real profile\")\nprofile_text = text!(ax, 0.7,0.0,text=model_number_str)\n\nrecord(f, \"X_evolution.gif\", profile_names[1:end];\n        framerate = 2) do profile_name\n    pname[] = profile_name\nend","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"(Image: Movie polytrope) Finally, we can also access the history data of the simulation. We use this to plot a simple HR diagram. As our mycrophysics are very simplistic, and the initial condition is not very physical, this looks a bit funny!","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Plot a funny HR diagram\nf = Figure()\nax = Axis(f[1,1], xlabel=L\"\\log_{10}(T_\\mathrm{eff}/[K])\", ylabel=L\"\\log_{10}(L/L_\\odot)\", xreversed=true)\nhistory = Evolution.get_history_dataframe_from_hdf5(\"history.hdf5\")\nlines!(ax, log10.(history[!,\"T_surf\"]), log10.(history[!,\"L_surf\"]))\nf","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"Internally we want to prevent storing any of the hdf5 files into our git repos, so I remove them. You can also take advantage of julia as a scripting language to post-process your simulation output in a similar way.","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"##Perform some cleanup\nrm(\"history.hdf5\")\nrm(\"profiles.hdf5\")\nrm(\"example_options.toml\")","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"NuclearBurning/","page":"Examples","title":"Examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Jems.jl","page":"Home","title":"Jems.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Jems","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Jems.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jems is a package designed for performing stellar structure and evolution calculations. Its main module is Evolution where a stellar model can be initialized and evolved according to user-defined equations. On the other hand, all the other modules can be used independently through their public interfaces.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jems contains the following modules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"Chem.md\",\n    \"Constants.md\",\n    \"EOS.md\",\n    \"Evolution.md\",\n    \"Opacity.md\",\n]","category":"page"}]
}
