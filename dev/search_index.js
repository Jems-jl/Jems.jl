var documenterSearchIndex = {"docs":
[{"location":"Opacity/#Opacity","page":"Opacity","title":"Opacity","text":"","category":"section"},{"location":"Opacity/","page":"Opacity","title":"Opacity","text":"The Opacity module of Jems handles all things related to the opacity of stellar matter.","category":"page"},{"location":"Opacity/","page":"Opacity","title":"Opacity","text":"Modules = [Jems.Opacity]","category":"page"},{"location":"Opacity/#Jems.Opacity.AbstractOpacity","page":"Opacity","title":"Jems.Opacity.AbstractOpacity","text":"abstract type AbstractOpacity\n\nAbstract supertype from which all defined opacity laws must derive, ie:\n\nstruct MyOpacity <: AbstractOpacity\n\n\n\n\n\n","category":"type"},{"location":"Opacity/#Jems.Opacity.get_opacity_resultsTP-Union{Tuple{TT}, Tuple{Jems.Opacity.SimpleElectronScatteringOpacity, TT, TT, AbstractVector{<:TT}, Vector{Symbol}}} where TT<:Real","page":"Opacity","title":"Jems.Opacity.get_opacity_resultsTP","text":"get_opacity_resultsTP(opacity::SimpleElectronScatteringOpacity, lnT::TT, lnP::TT, xa::Vector{<:TT},\n                        species::Vector{Symbol})::TT where {TT<:Real}\n\nEvaluates the opacity of the current mixture with mass fractions xa, species symbols species (both these should be of length nspecies), the natural log of temperature and pressure lnT, lnP, and the opacity law opacity.\n\n\n\n\n\n","category":"method"},{"location":"style/#Style-Guide","page":"Style Guide","title":"Style Guide","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"When developing Jems, please take into account the following style pointers.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"We use 4 spaces as the indent marker, and use a line length of 120. This is not strictly enforced, but try to keep overrunning lines to a minimum.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Docstrings are demarked by three double quotes:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    my_func(a::Number)\n\nThis function does something cool with number `a`.\n\"\"\"","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Comments are marked with the hashtag and a space:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"# this loop does good stuff!\nfor i = 1:10\n    a += 1\nend","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Inline comments should be separated by at least two spaces:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"c = a + b  # this is high level stuff!","category":"page"},{"location":"style/#JuliaFormatter","page":"Style Guide","title":"JuliaFormatter","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The file .JuliaFormatter.toml is be used in conjunction with JuliaFormatter.jl to automatically format source files according to our adopted style:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"JuliaFormatter.format(\".\")  # formats the whole directory of source files","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The main function of the formatter is that it will automatically fold long lines, and inserts spaces around operators. One disadvantance is that it ignores comments and does not yet handle docstrings (even if the .toml file explicitly says to include docstrings, this is a bug).","category":"page"},{"location":"Evolution/#Evolution","page":"Evolution","title":"Evolution","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"The Evolution module of Jems contains the basic tools needed to combine all other modules to perform stellar evolution. It allows a fully customizable definition of the equations that are solved together with their boundary conditions.","category":"page"},{"location":"Evolution/#StellarModel.jl","page":"Evolution","title":"StellarModel.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/StellarModel.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.StellarModel","page":"Evolution","title":"Jems.Evolution.StellarModel","text":"mutable struct StellarModel{TN<:Real,TD<:Real,TEOS<:EOS.AbstractEOS,TKAP<:Opacity.AbstractOpacity}\n\nAn evolutionary model for a star, containing information about the star's current state, as well as the independent variables of the model and its equations.\n\nThe struct has four parametric types, TN for 'normal' numbers, TD for dual numbers used in automatic differentiation, TEOS for the type of EOS being used and TKAP for the type of opacity law being used.\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.StellarModel-Tuple{Vector{Symbol}, Vector{Function}, Int64, Int64, Int64, Jems.EOS.AbstractEOS, Jems.Opacity.AbstractOpacity}","page":"Evolution","title":"Jems.Evolution.StellarModel","text":"StellarModel(varnames::Vector{Symbol}, structure_equations::Vector{Function},\n             nvars::Int, nspecies::Int, nz::Int, eos::AbstractEOS, opacity::AbstractOpacity)\n\nConstructor for a StellarModel instance, using varnames for the independent variables, functions of the structure_equations to be solved, number of independent variables nvars, number of species in the network nspecies number of zones in the model nz and an iterface to the EOS and Opacity laws.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.StellarStepInfo","page":"Evolution","title":"Jems.Evolution.StellarStepInfo","text":"mutable struct StellarStepInfo{TN<:Real}\n\nInformation used for a simulation step. A single stellar model can have three different objects of type StellarStepInfo, containing information from the previous step, information right before the Newton solver, and information after the Newton solver has completed.\n\nThe struct has one parametric type, TN to represent 'normal' numbers. No fields here need to have dual numbers as these will not be used in automatic differentiation routines.\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.TypeStableEquation","page":"Evolution","title":"Jems.Evolution.TypeStableEquation","text":"struct TypeStableEquation{TS,TD<:Real}\n\nStructure that wraps a stellar structure equation into a type stable object, using FunctionWrappers.jl. This requires that the stellar structure equations have the following signature:\n\nfunction structure_equation(::TS, ::Int,\n                            ::Matrix{TD}, ::Matrix{TD}, ::Matrix{TD},\n                            ::EOSResults{TD}, ::EOSResults{TD}, ::EOSResults{TD}\n                            ::TD, ::TD, ::TD)::TD\n\nFor typical usage, TS is the concrete type of StellarModel, and TD the type of dual number being used for automatic differentiation. The function must return an object of type TD, the result of the equation.\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.init_diff_cache!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.init_diff_cache!","text":"init_diff_cache!(sm::StellarModel)\n\nInitializes the diffcaches to the values of the independent variables, and sets ones in the correct spots where the dxi^k/dx_i^k entries lie.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Options.jl","page":"Evolution","title":"Options.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Options.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.IOOptions","page":"Evolution","title":"Jems.Evolution.IOOptions","text":"mutable struct IOOptions\n\nSubstructure of Options containing controls relating to input/output of data\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.Options","page":"Evolution","title":"Jems.Evolution.Options","text":"mutable struct Options\n\nStructure containing tweakable controls of Jems.\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.SolverOptions","page":"Evolution","title":"Jems.Evolution.SolverOptions","text":"mutable struct SolverOptions\n\nSubstructure of Options containing controls relating to the Newton solver\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.TerminationOptions","page":"Evolution","title":"Jems.Evolution.TerminationOptions","text":"mutable struct TerminationOptions\n\nSubstructure of Options containing controls relating to termination of the simulation\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.TimestepOptions","page":"Evolution","title":"Jems.Evolution.TimestepOptions","text":"mutable struct TimestepOptions\n\nSubstructure of Options containing controls relating to timestepping\n\n\n\n\n\n","category":"type"},{"location":"Evolution/#Jems.Evolution.set_options!-Tuple{Jems.Evolution.Options, String}","page":"Evolution","title":"Jems.Evolution.set_options!","text":"set_options!(opt::Options, toml_path::String)\n\nSets the controls in opt to the values supplied in the TOML file toml_path, containing key: value pairs. Invalid keys are not allowed, and an Exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Equations.jl","page":"Evolution","title":"Equations.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Equations.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.equationContinuity-Union{Tuple{TT}, Tuple{Jems.Evolution.StellarModel, Int64, Matrix{TT}, Matrix{TT}, Matrix{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, TT, TT, TT}} where TT<:Real","page":"Evolution","title":"Jems.Evolution.equationContinuity","text":"equationContinuity(sm::StellarModel, k::Int,\n                   varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n                   eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n                   κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of mass continuity, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with TypeStableEquation\n\nReturns\n\nResidual of comparing dr^3/dm with 3/(4πρ)\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationH1-Union{Tuple{TT}, Tuple{Jems.Evolution.StellarModel, Int64, Matrix{TT}, Matrix{TT}, Matrix{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, TT, TT, TT}} where TT<:Real","page":"Evolution","title":"Jems.Evolution.equationH1","text":"equationH1(sm::StellarModel, k::Int,\n           varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n           eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n           κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of Hydrogen 1 evoluation, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with TypeStableEquation\n\nReturns\n\nResidual of comparing dX_H1/dt with its computed reaction rate\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationHSE-Union{Tuple{TT}, Tuple{Jems.Evolution.StellarModel, Int64, Matrix{TT}, Matrix{TT}, Matrix{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, TT, TT, TT}} where TT<:Real","page":"Evolution","title":"Jems.Evolution.equationHSE","text":"equationHSE(sm::StellarModel, k::Int,\n            varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n            eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n            κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of hydrostatic equilibrium. Evaluates for cell k of StellarModel sm to what degree hydrostatic equilibrium is satisfied.\n\nArguments\n\nsm: Stellar Model\nk: cell number to consider\nvarm1: Matrix holding the dual numbers of the previous cell (k-1)\nvar00: Matrix holding the dual numbers of this cell (k)\nvarp1: Matrix holding the dual numbers of the next cell (k+1)\neosm1: EOSResults object holding the results of the EOS evaluation of the previous cell (k-1)\neos00: EOSResults object holding the results of the EOS evaluation of the current cell (k)\neosp1: EOSResults object holding the results of the EOS evaluation of the next cell (k+1)\nκm1: Opacity evaluated at the previous cell (k-1)\nκ00: Opacity evaluated at the current cell (k)\nκp1: Opacity evaluated at the next cell (k+1)\n\nReturns\n\nResidual of comparing dlnP/dm with -GM/4πr^4, where the latter is evaluated at the face of cell k and k+1.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationHe4-Union{Tuple{TT}, Tuple{Jems.Evolution.StellarModel, Int64, Matrix{TT}, Matrix{TT}, Matrix{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, TT, TT, TT}} where TT<:Real","page":"Evolution","title":"Jems.Evolution.equationHe4","text":"equationHe4(sm::StellarModel, k::Int,\n           varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n           eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n           κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of Helium 4 evoluation, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with TypeStableEquation\n\nReturns\n\nResidual of comparing He4 content with 1 minus the H1 content.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationLuminosity-Union{Tuple{TT}, Tuple{Jems.Evolution.StellarModel, Int64, Matrix{TT}, Matrix{TT}, Matrix{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, TT, TT, TT}} where TT<:Real","page":"Evolution","title":"Jems.Evolution.equationLuminosity","text":"equationLuminosity(sm::StellarModel, k::Int,\n                   varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n                   eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n                   κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of energy generation, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with TypeStableEquation\n\nReturns\n\nResidual of comparing dL/dm with ϵnuc - cₚ * dT/dt - (δ / ρ) * dP/dt\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationT-Union{Tuple{TT}, Tuple{Jems.Evolution.StellarModel, Int64, Matrix{TT}, Matrix{TT}, Matrix{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, Jems.EOS.EOSResults{TT}, TT, TT, TT}} where TT<:Real","page":"Evolution","title":"Jems.Evolution.equationT","text":"equationT(sm::StellarModel, k::Int,\n          varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n          eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n          κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of energy transport, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with TypeStableEquation\n\nReturns\n\nResidual of comparing dlnT/dm with -∇*GMT/4πr^4P, where the latter is evaluation at the face of cell k and k+1.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Solver.jl","page":"Evolution","title":"Solver.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/Solver.jl\"]","category":"page"},{"location":"Evolution/#EvolutionLoop.jl","page":"Evolution","title":"EvolutionLoop.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/EvolutionLoop.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.cycle_step_info!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.cycle_step_info!","text":"cycle_step_info!(sm::StellarModel)\n\nMoves the model info of the StellarModel sm over one state: start step info -> end step info -> previous step info -> start step info.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.do_evolution_loop-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.do_evolution_loop","text":"do_evolution_loop(sm::StellarModel)\n\nPerforms the main evolutionary loop of the input StellarModel sm. It continues taking steps until one of the termination criteria is reached (defined in sm.opt.termination).\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.get_dt_next-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.get_dt_next","text":"get_dt_next(sm::StellarModel)\n\nComputes the timestep of the next evolutionary step to be taken by the StellarModel sm by considering all timestep controls (sm.opt.timestep).\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.set_end_step_info!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.set_end_step_info!","text":"set_end_step_info(sm::StellarModel)\n\nSets the end step info (sm.esi) from current state of the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.set_start_step_info!-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.set_start_step_info!","text":"set_start_step_info!(sm::StellarModel)\n\nSets the start step info of the StellarModel sm by copying from the previous step info.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#InitialCondition.jl","page":"Evolution","title":"InitialCondition.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/InitialCondition.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.get_logdq-Union{Tuple{TT}, Tuple{Int64, Int64, TT, TT, Int64}} where TT<:Real","page":"Evolution","title":"Jems.Evolution.get_logdq","text":"get_logdq(k::Int, nz::Int, logdq_low::TT, logdq_high::TT, numregion::Int)::TT where {TT<:Real}\n\nComputes the logarithm mass chunk logdq for zone k of a profile with total zones nz, while keeping in mind to better resolve the first and last numregion zones of the profile. It linearly interpolates the value from the inputs logdq_low and logdq_high in these regions, while keeping logdq_high in the middle zones.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.n1_polytrope_initial_condition-Tuple{Jems.Evolution.StellarModel, Real, Real}","page":"Evolution","title":"Jems.Evolution.n1_polytrope_initial_condition","text":"n1_polytrope_initial_condition(sm::StellarModel, M::Real, R::Real; initial_dt=100 * SECYEAR)\n\nInitializes a stellar model sm with values corresponding to an n=1 polytrope, setting the independent variables sm.ind_vars, etc. accordingly. Also sets the initial timestep to be taken, initial_dt.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.θ_n-Tuple{Any}","page":"Evolution","title":"Jems.Evolution.θ_n","text":"θ_n(ξ) = sin(ξ) / ξ, the sinc function\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#IO.jl","page":"Evolution","title":"IO.jl","text":"","category":"section"},{"location":"Evolution/","page":"Evolution","title":"Evolution","text":"Modules = [Jems.Evolution]\nPages = [\"Evolution/IO.jl\"]","category":"page"},{"location":"Evolution/#Jems.Evolution.get_history_dataframe_from_hdf5-Tuple{Any}","page":"Evolution","title":"Jems.Evolution.get_history_dataframe_from_hdf5","text":"get_history_dataframe_from_hdf5(hdf5_filename)\n\nReturns a DataFrame object built from an hdf5 file, named hdf5_filename.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.get_profile_dataframe_from_hdf5-Tuple{Any, Any}","page":"Evolution","title":"Jems.Evolution.get_profile_dataframe_from_hdf5","text":"get_profile_dataframe_from_hdf5(hdf5_filename, profile_name)\n\nReturns a DataFrame object built from an hdf5 file, named hdf5_filename, considering the column named profile_name\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.get_profile_names_from_hdf5-Tuple{Any}","page":"Evolution","title":"Jems.Evolution.get_profile_names_from_hdf5","text":"get_profile_names_from_hdf5(hdf5_filename)\n\nRetruns the column names of the profile data contained in the hdf5 file hdf5_filename.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.history_get_ind_vars_edge_value-Tuple{Jems.Evolution.StellarModel, Symbol, Symbol}","page":"Evolution","title":"Jems.Evolution.history_get_ind_vars_edge_value","text":"history_get_ind_vars_edge_value(sm::StellarModel, var_symbol::Symbol, edge::Symbol)\n\nReturns the value of the independent variable var_symbol at either the surface or the center of the StellarModel sm. edge can be either :surface or :center.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.profile_get_ind_vars_value-Tuple{Jems.Evolution.StellarModel, Symbol, Int64}","page":"Evolution","title":"Jems.Evolution.profile_get_ind_vars_value","text":"profile_get_ind_vars_value(sm::StellarModel, var_symbol::Symbol, k::Int)\n\nReturns the value of the variable Symbol var_symbol at cell number k of the StellarModel sm.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.write_data-Tuple{Jems.Evolution.StellarModel}","page":"Evolution","title":"Jems.Evolution.write_data","text":"write_data(dm::StellarModel)\n\nSaves data (history/profile) for the current model, as required by the settings in sm.opt.io.\n\n\n\n\n\n","category":"method"},{"location":"Constants/#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"Constants/","page":"Constants","title":"Constants","text":"The Constants module of Jems defines a common set of physical and mathematical constants for use across the package.","category":"page"},{"location":"Constants/","page":"Constants","title":"Constants","text":"Modules = [Jems.Constants]","category":"page"},{"location":"Chem/#Chem","page":"Chem","title":"Chem","text":"","category":"section"},{"location":"Chem/","page":"Chem","title":"Chem","text":"The Chemistry module of Jems handles all things related to chemical mixtures and isotopes.","category":"page"},{"location":"Chem/","page":"Chem","title":"Chem","text":"Modules = [Jems.Chem]","category":"page"},{"location":"Chem/#Jems.Chem.Isotope","page":"Chem","title":"Jems.Chem.Isotope","text":"struct Isotope\n\nStructure containing basic info of an isotope:\n\nZ: atomic number (# protons)\nA: mass number (# protons + neutrons)\nname: its name (eg \"Hydrogen\")\nmass: atomic weight in amu\n\n\n\n\n\n","category":"type"},{"location":"Chem/#Jems.Chem.get_isotope_list-Tuple{}","page":"Chem","title":"Jems.Chem.get_isotope_list","text":"get_isotope_list()\n\nReturns a dictionary of all included isotopes in Jems, mapping symbols to Isotope objects.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#EOS","page":"EOS","title":"EOS","text":"","category":"section"},{"location":"EOS/","page":"EOS","title":"EOS","text":"The EOS module of Jems handles all things related to the equation of state of stellar matter.","category":"page"},{"location":"EOS/","page":"EOS","title":"EOS","text":"Modules = [Jems.EOS]","category":"page"},{"location":"EOS/#Jems.EOS.AbstractEOS","page":"EOS","title":"Jems.EOS.AbstractEOS","text":"abstract type AbstractEOS\n\nAbstract supertype from which all equations of state definitions must derive, ie:\n\nstruct MyEOS <: AbstractEOS\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.EOSResults","page":"EOS","title":"Jems.EOS.EOSResults","text":"mutable struct EOSResults{T1<:Real}\n\nStructure that holds various results from the evaluation of the EOS of a certain cell.\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.IdealEOS","page":"EOS","title":"Jems.EOS.IdealEOS","text":"struct IdealEOS <: AbstractEOS\n\nInterface of an Ideal gas equation of state\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.get_μ_IdealEOS-Union{Tuple{TT}, Tuple{AbstractVector{TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.get_μ_IdealEOS","text":"get_μ_IdealEOS(xa, species)\n\ncomputes the molecular weight of the mixture xa, given and list of species.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#Jems.EOS.set_EOS_resultsTP!-Union{Tuple{TT}, Tuple{Jems.EOS.IdealEOS, Jems.EOS.EOSResults{TT}, TT, TT, AbstractVector{TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.set_EOS_resultsTP!","text":"set_EOS_resultsTP!(eos::IdealEOS, r::EOSResults{TT}, lnT::TT, lnP::TT, xa::AbstractVector{TT},\n                       species::Vector{Symbol}) where {TT<:Real}\n\nComputes thermodynamical quantities of a mixture xa at temperature lnT and pressure lnP, given the ideal equation of state eos and list of species. The results are stored in the EOSResults object r.\n\n\n\n\n\n","category":"method"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"EditURL = \"../../examples/NuclearBurning.jl\"","category":"page"},{"location":"NuclearBurning/#NuclearBurning.jl","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"This notebook provides a simple example of a star with simplified mycrophysics undergoing nuclear burning. Import all necessary Jems modules. We will also do some benchmarks, so we import BenchmarkTools as well.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"using BenchmarkTools\nusing Jems.Chem\nusing Jems.Constants\nusing Jems.EOS\nusing Jems.Opacity\nusing Jems.Evolution","category":"page"},{"location":"NuclearBurning/#Model-creation","page":"NuclearBurning.jl","title":"Model creation","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We start by creating the stellar model. In this example we consider a model with 6 independent variables, two of which correspond to composition. The independent variables here are ln(P), ln(T), ln(r), the luminosity L and the mass fractions of Hydrogen and Helium.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"The Evolution module has pre-defined equations corresponding to these variables, which we provide here. For now, only a simple (fully ionized) ideal gas law EOS is available. Similarly, only a simple simple electron scattering opacity equal to kappa=02(1+X)mathrmcm^2g^-1 is available.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"nvars = 6\nnspecies = 2\nvarnames = [:lnP, :lnT, :lnr, :lum, :H1, :He4]\nstructure_equations = [Evolution.equationHSE, Evolution.equationT, Evolution.equationContinuity,\n                       Evolution.equationLuminosity, Evolution.equationH1, Evolution.equationHe4]\nnz = 1000\neos = EOS.IdealEOS(false)\nopacity = Opacity.SimpleElectronScatteringOpacity()\nsm = StellarModel(varnames, structure_equations, nvars, nspecies, nz, eos, opacity);\nnothing #hide","category":"page"},{"location":"NuclearBurning/#Initialize-StellarModel-and-evaluate-equations-and-jacobian","page":"NuclearBurning.jl","title":"Initialize StellarModel and evaluate equations and jacobian","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We do not have a working initial condition yet. We require pressure, temperature profiles. One simple available initial condition is that of an n=1 polytrope. This sets the pressure and density and computes the temperature from the EOS. The luminosity is initialized by assuming pure radiative transport for the temperature gradient produced by the polytrope.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"The normal evolution loop will store the information at the end of the step into an attribute of type StellarStepInfo, stored at sm.esi (end step info). After initializing our polytrope we can mimic that behavior by calling set_end_step_info!(sm). We then 'cycle' this info into the information of a hypothetical previous step with cycle_step_info, so now sm.psi contains our initial condition. Finally we call set_start_step_info to use sm.psi (previous step info) to populate the information needed before the Newton solver in sm.ssi (start step info). At last we are in position to evaluate the equations and compute the Jacobian.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Evolution.n1_polytrope_initial_condition(sm, MSUN, 100 * RSUN; initial_dt=10 * SECYEAR)\nEvolution.set_end_step_info!(sm)\nEvolution.cycle_step_info!(sm)\nEvolution.set_start_step_info!(sm)\nEvolution.eval_jacobian_eqs!(sm)","category":"page"},{"location":"NuclearBurning/#Benchmarking","page":"NuclearBurning.jl","title":"Benchmarking","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"The previous code leaves everything ready to solve the linearized system. We use the package LinearSolve for this, which provides various algorithms for linear systems defined by sparse arrays. In the future we might want to try additional solvers provided (for instance, solvers that make use of the Krylov space such as GMRES). Alternate solvers might work much better for systems with excessively large nuclear networks.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We can compute a simple benchmark of the time it takes to solve the linear system once. Each timestep will require multiple iterations of the Newton solver, so this would be a lower bound on the time that will take.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"using LinearSolve\n@benchmark begin\n    $sm.linear_solver.A = $sm.jacobian\n    $sm.linear_solver.b = $sm.eqs_numbers\n    corr = solve($sm.linear_solver)\nend","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"On my system, this takes on the order of 800 μs. Next up we can check how long it takes to compute a single row of the jacobian. With a row here I mean all the entries that correspond to one cell. The code below benchmarks the time it takes to compute the jacobian elements associated with row 2","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Benchmark one jacobian row","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"@benchmark Evolution.eval_jacobian_eqs_row!(sm, 2)","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Again on my machine, this takes sim 16mathrmmu s. This is a short amount of time, but we have a thousand cells to compute. Let's benchmark the calculation of the full jacobian.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Benchmark entire jacobian","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"@benchmark Evolution.eval_jacobian_eqs!(sm)","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"And on my computer, this took about 52mathrmms. Even though we have a thousand cells, the computation time was not a thousand times longer than computing the components of the jacobian for a single cell. The reason for this is that the calculation is parallelized so cells are done independently. However, I used 8 cores for my calculations, so the scaling is less than ideal. One of the main culprits here is the garbage collector. Current versions of julia can only perform garbage collection in a serial way, so it does not take advantage of all threads. Starting with julia 1.10, the garbage collector will be able to run in multiple threads, so that should alleviate issues with performance scaling.","category":"page"},{"location":"NuclearBurning/#Evolving-our-model","page":"NuclearBurning.jl","title":"Evolving our model","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We can now evolve our star! We will initiate a 1M_odot star with a radius of 100R_odot using an n=1 polytrope (it would be much better to use n=3 or n=3/2 polytropes, for now I only use this because there is a simple analytical solution). The star is expected to contract until it ignites hydrogen. We set a few options for the simulation with a toml file, which we generate dynamically. These simulation should complete in about a thousand steps once it reaches the max_center_T limit.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Output is stored in HDF5 files, and easy to use functions are provided with the Evolution module to turn these HDF5 files into DataFrame objects. HDF5 output is compressed by default.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"open(\"example_options.toml\", \"w\") do file\n    write(file,\n          \"\"\"\n          [solver]\n          newton_max_iter_first_step = 1000\n          newton_max_iter = 200\n\n          [timestep]\n          dt_max_increase = 2.0\n\n          [termination]\n          max_model_number = 3000\n          max_center_T = 4e7\n\n          [io]\n          profile_interval = 50\n          \"\"\")\nend\nEvolution.set_options!(sm.opt, \"./example_options.toml\")\nrm(sm.opt.io.hdf5_history_filename; force=true)\nrm(sm.opt.io.hdf5_profile_filename; force=true)\nEvolution.n1_polytrope_initial_condition(sm, MSUN, 100 * RSUN; initial_dt=1000 * SECYEAR)\n\n@time Evolution.do_evolution_loop(sm)","category":"page"},{"location":"NuclearBurning/#Plotting-with-Makie","page":"NuclearBurning.jl","title":"Plotting with Makie","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Now that our simulation is complete we can analyze the results. We make use of the Makie package for this. I'm not a fan of the Makie defaults, so I adjust them. I normally also adjust the fonts to be consistent with \\LaTeX, but I avoid that here so we don't need to distribute those fonts together with Jems.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"using CairoMakie, LaTeXStrings, MathTeXEngine\nbasic_theme = Theme(\n                    fonts = (regular = texfont(:text), bold = texfont(:bold),\n                    italic = texfont(:italic), bold_italic = texfont(:bolditalic)),\n                    fontsize=30, resolution=(1000, 750), linewidth=7,\n                    Axis=(xlabelsize=40, ylabelsize=40, titlesize=40, xgridvisible=false, ygridvisible=false,\n                          spinewidth=2.5, xminorticksvisible=true, yminorticksvisible=true, xtickalign=1, ytickalign=1,\n                          xminortickalign=1, yminortickalign=1, xticksize=14, xtickwidth=2.5, yticksize=14,\n                          ytickwidth=2.5, xminorticksize=7, xminortickwidth=2.5, yminorticksize=7, yminortickwidth=2.5,\n                          xticklabelsize=35, yticklabelsize=35, xticksmirrored=true, yticksmirrored=true),\n                    Legend=(patchsize=(70, 10), framevisible=false, patchlabelgap=20, rowgap=10))\nset_theme!(basic_theme)","category":"page"},{"location":"NuclearBurning/#Compare-against-polytropes","page":"NuclearBurning.jl","title":"Compare against polytropes","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Below we see how the profile of the star compares to different polytropes. We make use of the facility tools to obtain DataFrame objects out of the hdf5 output. In particular, get_profile_names_from_hdf5 will provide the names of all profiles contained within the hdf5 file, while get_profile_dataframe_from_hdf5 is used to obtain one DataFrame corresponding to one stellar profile. The animation is constructed using the Observable type that makie provides. Note that the zero points of the polytropes are arbitrary.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"profile_names = Evolution.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nf = Figure()\nax = Axis(f[1, 1]; xlabel=L\"\\log_{10}(\\rho/\\mathrm{[g\\;cm^{-3}]})\", ylabel=L\"\\log_{10}(P/\\mathrm{[dyn]})\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(Evolution.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\nlog10_ρ = @lift($profile[!, \"log10_ρ\"])\nlog10_P = @lift($profile[!, \"log10_P\"])\n\nprofile_line = lines!(ax, log10_ρ, log10_P; label=\"real profile\")\nxvals = LinRange(-13, 4, 100)\nlines!(ax, xvals, (1 + 1 / 1) .* xvals .+ 20; label=\"n=1\")\nlines!(ax, xvals, (1 + 1 / (1.5)) .* xvals .+ 15; label=\"n=1.5\")\nlines!(ax, xvals, (1 + 1 / 3) .* xvals .+ 15; label=\"n=3\")\naxislegend(ax; position=:rb)\n\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\nprofile_text = text!(ax, -10, 20; text=model_number_str)\n\nrecord(f, \"rho_P_evolution.gif\", profile_names[1:end]; framerate=2) do profile_name\n    pname[] = profile_name\nend","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"(Image: Movie polytrope)","category":"page"},{"location":"NuclearBurning/#Check-nuclear-burning","page":"NuclearBurning.jl","title":"Check nuclear burning","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"We see that the structure evolves towards an n=3 polytrope. Deviations near the core are due to the non-homogeneous composition as hydrogen is burnt. We can similarly visualize how the hydrogen mass fraction changes in the simulation. In here only one frame shows the hydrogen that was burnt, to better visualize that you can adjust profile_interval in the Io options (and probably adjust the framerate).","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"profile_names = Evolution.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nf = Figure()\nax = Axis(f[1, 1]; xlabel=L\"\\mathrm{Mass}\\;[M_\\odot]\", ylabel=L\"X\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(Evolution.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\nmass = @lift($profile[!, \"mass\"])\nX = @lift($profile[!, \"X\"])\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\n\nprofile_line = lines!(ax, mass, X; label=\"real profile\")\nprofile_text = text!(ax, 0.7, 0.0; text=model_number_str)\n\nrecord(f, \"X_evolution.gif\", profile_names[1:end]; framerate=2) do profile_name\n    pname[] = profile_name\nend","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"(Image: Movie polytrope)","category":"page"},{"location":"NuclearBurning/#Plot-a-funny-HR-diagram","page":"NuclearBurning.jl","title":"Plot a funny HR diagram","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Finally, we can also access the history data of the simulation. We use this to plot a simple HR diagram. As our microphysics are very simplistic, and the initial condition is not very physical, this looks a bit funny!","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"f = Figure()\nax = Axis(f[1, 1]; xlabel=L\"\\log_{10}(T_\\mathrm{eff}/[K])\", ylabel=L\"\\log_{10}(L/L_\\odot)\", xreversed=true)\nhistory = Evolution.get_history_dataframe_from_hdf5(\"history.hdf5\")\nlines!(ax, log10.(history[!, \"T_surf\"]), log10.(history[!, \"L_surf\"]))\nf","category":"page"},{"location":"NuclearBurning/#Perform-some-cleanup","page":"NuclearBurning.jl","title":"Perform some cleanup","text":"","category":"section"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"Internally we want to prevent storing any of the hdf5 files into our git repos, so I remove them. You can also take advantage of julia as a scripting language to post-process your simulation output in a similar way.","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"rm(\"history.hdf5\")\nrm(\"profiles.hdf5\")\nrm(\"example_options.toml\")","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"","category":"page"},{"location":"NuclearBurning/","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Jems.jl","page":"Home","title":"Jems.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Jems","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Jems.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jems is a package designed for performing stellar structure and evolution calculations. Its main module is Evolution where a stellar model can be initialized and evolved according to user-defined equations. On the other hand, all the other modules can be used independently through their public interfaces.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jems contains the following modules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"Chem.md\",\n    \"Constants.md\",\n    \"EOS.md\",\n    \"Evolution.md\",\n    \"Opacity.md\",\n]","category":"page"}]
}
