var documenterSearchIndex = {"docs":
[{"location":"Chem/#Chem","page":"Chem","title":"Chem","text":"The Chemistry module of Jems handles all things related to chemical mixtures and isotopes.","category":"section"},{"location":"Chem/#Jems.Chem.Isotope","page":"Chem","title":"Jems.Chem.Isotope","text":"struct Isotope\n\nStructure containing basic info of an isotope:\n\nZ: atomic number (# protons)\nA: mass number (# protons + neutrons)\nname: its name (eg \"Hydrogen\")\nmass: atomic weight in amu\n\n\n\n\n\n","category":"type"},{"location":"Chem/#Jems.Chem.get_isotope_list-Tuple{}","page":"Chem","title":"Jems.Chem.get_isotope_list","text":"get_isotope_list()\n\nReturns a dictionary of all included isotopes in Jems, mapping symbols to Isotope objects.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#EOS","page":"EOS","title":"EOS","text":"The EOS module of Jems handles all things related to the equation of state of stellar matter.","category":"section"},{"location":"EOS/#Jems.EOS.AbstractEOS","page":"EOS","title":"Jems.EOS.AbstractEOS","text":"abstract type AbstractEOS\n\nAbstract supertype from which all equations of state definitions must derive, ie:\n\nstruct MyEOS <: AbstractEOS\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.EOSResults","page":"EOS","title":"Jems.EOS.EOSResults","text":"mutable struct EOSResults{T1<:Real}\n\nStructure that holds various results from the evaluation of the EOS of a certain cell.\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.IdealEOS","page":"EOS","title":"Jems.EOS.IdealEOS","text":"struct IdealEOS <: AbstractEOS\n\nInterface of an Ideal gas equation of state\n\n\n\n\n\n","category":"type"},{"location":"EOS/#Jems.EOS.get_μ_IdealEOS-Union{Tuple{TT}, Tuple{AbstractVector{TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.get_μ_IdealEOS","text":"get_μ_IdealEOS(xa, species)\n\ncomputes the molecular weight of the mixture xa, given and list of species.\n\n\n\n\n\n","category":"method"},{"location":"EOS/#Jems.EOS.set_EOS_resultsTρ!-Union{Tuple{TT}, Tuple{Jems.EOS.IdealEOS, Jems.EOS.EOSResults{TT}, TT, TT, AbstractVector{TT}, Vector{Symbol}}} where TT<:Real","page":"EOS","title":"Jems.EOS.set_EOS_resultsTρ!","text":"set_EOS_resultsTP!(eos::IdealEOS, r::EOSResults{TT}, lnT::TT, lnP::TT, xa::AbstractVector{TT},\n                       species::Vector{Symbol}) where {TT<:Real}\n\nComputes thermodynamical quantities of a mixture xa at temperature lnT and pressure lnP, given the ideal equation of state eos and list of species. The results are stored in the EOSResults object r.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#StellarModels","page":"StellarModels","title":"StellarModels","text":"The StellarModels module of Jems defines models that it can evolve, along with their properties, initialization, IO operations, and option configuration.","category":"section"},{"location":"StellarModels/#StellarModel.jl","page":"StellarModels","title":"StellarModel.jl","text":"","category":"section"},{"location":"StellarModels/#StellarModelProperties.jl","page":"StellarModels","title":"StellarModelProperties.jl","text":"","category":"section"},{"location":"StellarModels/#OneZone.jl","page":"StellarModels","title":"OneZone.jl","text":"","category":"section"},{"location":"StellarModels/#Options.jl","page":"StellarModels","title":"Options.jl","text":"","category":"section"},{"location":"StellarModels/#InitialCondition.jl","page":"StellarModels","title":"InitialCondition.jl","text":"","category":"section"},{"location":"StellarModels/#IO.jl","page":"StellarModels","title":"IO.jl","text":"","category":"section"},{"location":"StellarModels/#Remesher.jl","page":"StellarModels","title":"Remesher.jl","text":"","category":"section"},{"location":"StellarModels/#PlotterInterface.jl","page":"StellarModels","title":"PlotterInterface.jl","text":"","category":"section"},{"location":"StellarModels/#Jems.StellarModels.StellarModel","page":"StellarModels","title":"Jems.StellarModels.StellarModel","text":"mutable struct StellarModel{TN<:Real,TD<:Real,TEOS<:EOS.AbstractEOS,TKAP<:Opacity.AbstractOpacity}\n\nAn evolutionary model for a star, containing information about the star's current state, as well as the independent variables of the model and its equations.\n\nThe struct has four parametric types, TN for 'normal' numbers, TD for dual numbers used in automatic differentiation, TEOS for the type of EOS being used and TKAP for the type of opacity law being used.\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.StellarModel-Tuple{Vector{Symbol}, Vector{Symbol}, Vector{Function}, Function, Int64, Int64, Vector{Function}, Jems.NuclearNetworks.NuclearNetwork, Jems.EOS.AbstractEOS, Jems.Opacity.AbstractOpacity, Jems.Turbulence.AbstractTurb}","page":"StellarModels","title":"Jems.StellarModels.StellarModel","text":"StellarModel(varnames::Vector{Symbol}, structure_equations::Vector{Function},\n            nvars::Int, nspecies::Int, nz::Int, eos::AbstractEOS, opacity::AbstractOpacity)\n\nConstructor for a StellarModel instance, using varnames for the independent variables, functions of the structure_equations to be solved, number of independent variables nvars, number of species in the network nspecies number of zones in the model nz and an iterface to the EOS and Opacity laws.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.adjusted_stellar_model_data-Tuple{Any, Int64, Int64}","page":"StellarModels","title":"Jems.StellarModels.adjusted_stellar_model_data","text":"adjusted_stellar_model_data(sm, new_nz::Int, new_nextra::Int)\n\nReturns a new copy of sm with an adjusted allocated size. This creates a full duplicate without removing the old stellar model, which is not very memory friendly. One possible optimization for the future. The new model is created to have new_nz zones with an extra padding of new_nextra zones to allow for remeshing. The new model will copy the contents of\n\nind_vars\nmstar\nm\ndm\ntime\ndt\nmodel_number\npsi, ssi, esi\nopt As well as the nuclear network, opacity and EOS.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.cycle_props!-Tuple{Jems.StellarModels.StellarModel}","page":"StellarModels","title":"Jems.StellarModels.cycle_props!","text":"cycle_props!(sm::StellarModel)\n\nMoves the model properties of the StellarModel sm over one state: startstepprops -> props -> prvstepprops -> startstepprops\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.uncycle_props!-Tuple{Jems.StellarModels.StellarModel}","page":"StellarModels","title":"Jems.StellarModels.uncycle_props!","text":"uncycle_props!(sm::StellarModel)\n\nMoves the model properties of the StellarModel sm back one state: startstepprops <- props <- prvstepprops <- startstepprops\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.copy_mesh_properties!-Tuple{Any, Any, Any}","page":"StellarModels","title":"Jems.StellarModels.copy_mesh_properties!","text":"function copy_mesh!(sm, props_in, props_out)\n\nCopies over the mesh quantities, i.e., nz, m, dm, and ind_vars from props_in into props_out.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.evaluate_stellar_model_properties!-Union{Tuple{TCellDualData}, Tuple{TDual}, Tuple{TN}, Tuple{Any, Jems.StellarModels.StellarModelProperties{TN, TDual, TCellDualData}}} where {TN<:Real, TDual<:ForwardDiff.Dual, TCellDualData}","page":"StellarModels","title":"Jems.StellarModels.evaluate_stellar_model_properties!","text":"function evaluate_stellar_model_properties!(sm, props::StellarModelProperties{TDual, TCellDualData}) where\n    {TDual <: ForwardDiff.Dual, TCellDualData}\n\nEvaluates the stellar model properties props from the ind_vars array. The goal is to save the 'state' of the StellarModel so we can easily get properties like rates, eos, opacity values, and retrace if a retry is called. This does not update the mesh/ind_vars arrays.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.OneZone","page":"StellarModels","title":"Jems.StellarModels.OneZone","text":"OneZone(varnames::Vector{Symbol}, composition_equation::Function,\n            nvars::Int, nspecies::Int)\n\nConstructor for a OneZone instance, using varnames for the independent variables, the composition equation to be solved, number of independent variables nvars, number of species in the network nspecies\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.OneZone-2","page":"StellarModels","title":"Jems.StellarModels.OneZone","text":"mutable struct OneZone{TNUMBER<:Real,TDUALFULL<:ForwardDiff.Dual,\n                          TPROPS<:StellarModels.AbstractModelProperties,\n                          TNET<:NuclearNetworks.AbstractNuclearNetwork,\n                          TSOLVER<:StellarModels.AbstractSolverData}\n\nStructure definition of a model having one internal zone.\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.evaluate_one_zone_properties!-Union{Tuple{TDual}, Tuple{TN}, Tuple{Any, Jems.StellarModels.OneZoneProperties{TN, TDual}}} where {TN<:Real, TDual<:ForwardDiff.Dual}","page":"StellarModels","title":"Jems.StellarModels.evaluate_one_zone_properties!","text":"function evaluate_stellar_model_properties!(oz, props::StellarModelProperties{TDual, TCellDualData}) where\n    {TDual <: ForwardDiff.Dual, TCellDualData}\n\nEvaluates the stellar model properties props from the ind_vars array. The goal is to save the 'state' of the StellarModel so we can easily get properties like rates, eos, opacity values, and retrace if a retry is called. This does not update the mesh/ind_vars arrays.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.IOOptions","page":"StellarModels","title":"Jems.StellarModels.IOOptions","text":"mutable struct IOOptions\n\nSubstructure of Options containing controls relating to input/output of data\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.Options","page":"StellarModels","title":"Jems.StellarModels.Options","text":"mutable struct Options\n\nStructure containing tweakable controls of Jems.\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.PhysicsOptions","page":"StellarModels","title":"Jems.StellarModels.PhysicsOptions","text":"mutable struct PhysicsOptions\n\nOptions that affect the physics of the computed model\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.RemeshOptions","page":"StellarModels","title":"Jems.StellarModels.RemeshOptions","text":"mutable struct RemeshOptions\n\nSubstructure of Options containing controls relating to remeshing\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.SolverOptions","page":"StellarModels","title":"Jems.StellarModels.SolverOptions","text":"mutable struct SolverOptions\n\nSubstructure of Options containing controls relating to the Newton solver\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.TerminationOptions","page":"StellarModels","title":"Jems.StellarModels.TerminationOptions","text":"mutable struct TerminationOptions\n\nSubstructure of Options containing controls relating to termination of the simulation\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.TimestepOptions","page":"StellarModels","title":"Jems.StellarModels.TimestepOptions","text":"mutable struct TimestepOptions\n\nSubstructure of Options containing controls relating to timestepping\n\n\n\n\n\n","category":"type"},{"location":"StellarModels/#Jems.StellarModels.set_options!-Tuple{Jems.StellarModels.Options, String}","page":"StellarModels","title":"Jems.StellarModels.set_options!","text":"set_options!(opt::Options, toml_path::String)\n\nSets the controls in opt to the values supplied in the TOML file toml_path, containing key: value pairs. Invalid keys are not allowed, and an Exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.RungeKutta_LaneEmden-Tuple{Any}","page":"StellarModels","title":"Jems.StellarModels.RungeKutta_LaneEmden","text":"RungeKutta_LaneEmden(n)\n\nComputes the solution of the Lane-Emden equation for polytropic index n until the first zero by returning xvals, containing ξ values; yvals, containing the corresponding function values θn; and zvals, containing the derivative. This naming convention for x (=independent variable), y (=corresponding solution values) and z (=corresponding derivative values) is used throughout this function. The Lane-Emden equation is solved by performing the Runge-Kutta method of order 4. The stepsize is allowed to decrease as the function reaches the first zero. The function takes care of the core boundary conditions at ξ=0. The last ξ value (i.e. the first zero of the Lane-Emden solution) is calculated by linearly extrapolating the last two points of the solution. This first zero ξ1 can be found as xvals[end].\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.get_logdq-Union{Tuple{TT}, Tuple{Int64, Int64, TT, TT, TT, Int64}} where TT<:Real","page":"StellarModels","title":"Jems.StellarModels.get_logdq","text":"get_logdq(k::Int, nz::Int, logdq_low::TT, logdq_high::TT, numregion::Int)::TT where {TT<:Real}\n\nComputes the logarithm mass chunk logdq for zone k of a profile with total zones nz, while keeping in mind to better resolve the first and last numregion zones of the profile. It linearly interpolates the value from the inputs logdq_low and logdq_high in these regions, while keeping logdq_high in the middle zones.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.getlnT_NewtonRhapson-NTuple{5, Any}","page":"StellarModels","title":"Jems.StellarModels.getlnT_NewtonRhapson","text":"getlnT_NewtonRhapson(lnT_initial, lnρ, P, massfractions, eos)\n\nComputes the temperature lnT starting from a density lnρ, a pressure P, a composition xa, a species species and an equation of state eos. The equation of state gives us the pressure,  given a certain temperature and density. The idea is to match this pressure with the given pressure P by fitting the temperature. Starting from an initial guess lnT_initial,  the Newton-Rhapson method is used to converge to the final temperature in an interative way. Each iteration, a new lnT is computed according to the Newton-Rhapson formula using the derivative dlnP/dlnT. Next, based on this new lnT, the equation of state returns a new pressure. The algorithm stops when the difference between the calculated pressure and the given pressure is smaller than a certain threshold. The temperature at which this occurs is returned.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.n_polytrope_initial_condition!-Tuple{Any, Jems.StellarModels.StellarModel, Int64, Any, Any, Any, Jems.Chem.AbundanceList, Real, Real}","page":"StellarModels","title":"Jems.StellarModels.n_polytrope_initial_condition!","text":"n_polytrope_initial_condition(n,sm::StellarModel, M::Real, R::Real; initial_dt=100 * SECYEAR)\n\nInitializes the stellar model properties sm.props with a mesh of size nz with values corresponding to a polytrope of index n, setting sm.props.m, sm.props.dm and the independent variables sm.props.ind_vars, etc. accordingly. Also sets the initial timestep to be taken, initial_dt. It first calls the solution to the Lane-Emden equation for index n and then sets radii, densities, pressures and luminosities.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.create_output_files!-Tuple{Jems.StellarModels.AbstractModel}","page":"StellarModels","title":"Jems.StellarModels.create_output_files!","text":"create_output_files(sm::StellarModel)\n\nCreates output files for history and profile data\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.get_history_dataframe_from_hdf5-Tuple{Any}","page":"StellarModels","title":"Jems.StellarModels.get_history_dataframe_from_hdf5","text":"get_history_dataframe_from_hdf5(hdf5_filename)\n\nReturns a DataFrame object built from an hdf5 file, named hdf5_filename.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.get_profile_dataframe_from_hdf5-Tuple{Any, Any}","page":"StellarModels","title":"Jems.StellarModels.get_profile_dataframe_from_hdf5","text":"get_profile_dataframe_from_hdf5(hdf5_filename, profile_name)\n\nReturns a DataFrame object built from an hdf5 file, named hdf5_filename, considering the column named profile_name\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.get_profile_names_from_hdf5-Tuple{Any}","page":"StellarModels","title":"Jems.StellarModels.get_profile_names_from_hdf5","text":"get_profile_names_from_hdf5(hdf5_filename)\n\nRetruns the column names of the profile data contained in the hdf5 file hdf5_filename.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.write_data-Tuple{Jems.StellarModels.AbstractModel}","page":"StellarModels","title":"Jems.StellarModels.write_data","text":"write_data(sm::StellarModel)\n\nSaves data (history/profile) for the current model, as required by the settings in sm.opt.io.\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.adjust_props_size!-Tuple{Jems.StellarModels.StellarModel, Int64, Int64}","page":"StellarModels","title":"Jems.StellarModels.adjust_props_size!","text":"adjust_props_size(sm, new_nz::Int, nextra::Int)\n\nReturns a new StellarModelProperties object with an adjusted size. Copies over the following from the currect active properties:\n\nnz\ndt\ntime\nind_vars\nmstar\nm\ndm\n\n\n\n\n\n","category":"method"},{"location":"StellarModels/#Jems.StellarModels.remesher!-Tuple{Jems.StellarModels.StellarModel}","page":"StellarModels","title":"Jems.StellarModels.remesher!","text":"remesher!\n\nActs on sm.startstepprops using info from sm.prvstepprops to decide whether to merge/split cells\n\n\n\n\n\n","category":"method"},{"location":"style/#Style-Guide","page":"Style Guide","title":"Style Guide","text":"When developing Jems, please take into account the following style pointers.\n\nWe use 4 spaces as the indent marker, and use a line length of 120. This is not strictly enforced, but try to keep overrunning lines to a minimum.\n\nDocstrings are demarked by three double quotes:\n\n\"\"\"\n    my_func(a::Number)\n\nThis function does something cool with number `a`.\n\"\"\"\n\nComments are marked with the hashtag and a space:\n\n# this loop does good stuff!\nfor i = 1:10\n    a += 1\nend\n\nInline comments should be separated by at least two spaces:\n\nc = a + b  # this is high level stuff!","category":"section"},{"location":"style/#JuliaFormatter","page":"Style Guide","title":"JuliaFormatter","text":"The file .JuliaFormatter.toml is be used in conjunction with JuliaFormatter.jl to automatically format source files according to our adopted style:\n\nJuliaFormatter.format(\".\")  # formats the whole directory of source files\n\nThe main function of the formatter is that it will automatically fold long lines, and inserts spaces around operators. One disadvantance is that it ignores comments and does not yet handle docstrings (even if the .toml file explicitly says to include docstrings, this is a bug).","category":"section"},{"location":"Evolution/#Evolution","page":"Evolution","title":"Evolution","text":"The Evolution module of Jems contains the basic tools needed to combine all other modules to perform stellar evolution. It allows a fully customizable definition of the equations that are solved together with their boundary conditions.","category":"section"},{"location":"Evolution/#Equations.jl","page":"Evolution","title":"Equations.jl","text":"","category":"section"},{"location":"Evolution/#Evaluation.jl","page":"Evolution","title":"Evaluation.jl","text":"","category":"section"},{"location":"Evolution/#Solver.jl","page":"Evolution","title":"Solver.jl","text":"","category":"section"},{"location":"Evolution/#EvolutionLoop.jl","page":"Evolution","title":"EvolutionLoop.jl","text":"","category":"section"},{"location":"Evolution/#Jems.Evolution.equationContinuity-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.equationContinuity","text":"equationContinuity(sm::StellarModel, k::Int,\n                   varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n                   eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n                   rates::Matrix{TT},\n                   κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of mass continuity, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with StellarModels.TypeStableEquation\n\nReturns\n\nResidual of comparing dr^3/dm with 3/(4πρ)\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationHSE-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.equationHSE","text":"equationHSE(sm::StellarModel, k::Int,\n            # varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n            # eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n            # rates::Matrix{TT},\n            # κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of hydrostatic equilibrium. Evaluates for cell k of StellarModel sm to what degree hydrostatic equilibrium is satisfied.\n\nArguments\n\nsm: Stellar Model\nk: cell number to consider\n\n- varm1: Matrix holding the dual numbers of the previous cell (k-1)\n\n- var00: Matrix holding the dual numbers of this cell (k)\n\n- varp1: Matrix holding the dual numbers of the next cell (k+1)\n\n- eosm1: EOSResults object holding the results of the EOS evaluation of the previous cell (k-1)\n\n- eos00: EOSResults object holding the results of the EOS evaluation of the current cell (k)\n\n- eosp1: EOSResults object holding the results of the EOS evaluation of the next cell (k+1)\n\n- κm1: Opacity evaluated at the previous cell (k-1)\n\n- κ00: Opacity evaluated at the current cell (k)\n\n- κp1: Opacity evaluated at the next cell (k+1)\n\nReturns\n\nResidual of comparing dlnP/dm with -GM/4πr^4, where the latter is evaluated at the face of cell k and k+1.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationLuminosity-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.equationLuminosity","text":"equationLuminosity(sm::StellarModel, k::Int,\n                   varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n                   eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n                   rates::Matrix{TT},\n                   κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of energy generation, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with StellarModels.TypeStableEquation\n\nReturns\n\nResidual of comparing dL/dm with ϵnuc - cₚ * dT/dt - (δ / ρ) * dP/dt\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equationT-Tuple{Jems.StellarModels.StellarModel, Int64}","page":"Evolution","title":"Jems.Evolution.equationT","text":"equationT(sm::StellarModel, k::Int,\n          varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n          eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n          rates::Matrix{TT},\n          κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation of energy transport, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with StellarModels.TypeStableEquation\n\nReturns\n\nResidual of comparing dlnT/dm with -∇*GMT/4πr^4P, where the latter is evaluated at the face of cell k and k+1.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.equation_composition-Tuple{Jems.StellarModels.StellarModel, Int64, Symbol}","page":"Evolution","title":"Jems.Evolution.equation_composition","text":"equation_composition(sm::StellarModel, k::Int, iso_name::Symbol,\n                     varm1::Matrix{TT}, var00::Matrix{TT}, varp1::Matrix{TT},\n                     eosm1::EOSResults{TT}, eos00::EOSResults{TT}, eosp1::EOSResults{TT},\n                     rates::Matrix{TT},\n                     κm1::TT, κ00::TT, κp1::TT)::TT where {TT<:Real}\n\nDefault equation for composition evolution for isotope iso_name, evaluated for cell k of StellarModel sm.\n\nArguments\n\nIdentical to equationHSE for compatibility with StellarModels.TypeStableEquation\n\nReturns\n\nResidual of comparing dX_i/dt with its computed reaction rate\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.eval_cell_eqs!-Tuple{Jems.StellarModels.AbstractModel, Int64}","page":"Evolution","title":"Jems.Evolution.eval_cell_eqs!","text":"eval_cell_eqs(m::StellarModel, k::Int, ind_vars_view::Vector{<:TT}) where{TT<:Real}\n\nEvaluates the stellar structure equations of the model, m, at cell k, given the view of the independent variables, ind_vars_view.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.eval_jacobian_eqs!-Tuple{Jems.StellarModels.AbstractModel}","page":"Evolution","title":"Jems.Evolution.eval_jacobian_eqs!","text":"eval_jacobian_eqs!(m::StellarModel)\n\nEvaluates the whole Jacobian matrix and equations of the given StellarModel m.\n\n\n\n\n\n","category":"method"},{"location":"Evolution/#Jems.Evolution.eval_jacobian_eqs_row!-Tuple{Jems.StellarModels.AbstractModel, Int64}","page":"Evolution","title":"Jems.Evolution.eval_jacobian_eqs_row!","text":"eval_jacobian_eqs_row!(m::AbstractModel, k::int)\n\nEvaluates row k of the Jacobian matrix of the given Model m.\n\n\n\n\n\n","category":"method"},{"location":"NuclearBurning/#NuclearBurning.jl","page":"NuclearBurning.jl","title":"NuclearBurning.jl","text":"This notebook provides a simple example of a star with simplified microphysics undergoing nuclear burning. Import all necessary Jems modules. We will also do some benchmarks, so we import BenchmarkTools as well.\n\nusing BenchmarkTools\nusing Jems.Chem\nusing Jems.Constants\nusing Jems.EOS\nusing Jems.Opacity\nusing Jems.NuclearNetworks\nusing Jems.Turbulence\nusing Jems.StellarModels\nusing Jems.Evolution\nusing Jems.Plotting","category":"section"},{"location":"NuclearBurning/#Model-creation","page":"NuclearBurning.jl","title":"Model creation","text":"We start by creating the stellar model. In this example we consider a model with 6 independent variables, two of which correspond to composition. The independent variables here are ln(P), ln(T), ln(r), the luminosity L and the mass fractions of Hydrogen and Helium.\n\nThe Evolution module has pre-defined equations corresponding to these variables, which we provide here. For now, only a simple (fully ionized) ideal gas law EOS is available. Similarly, only a simple simple electron scattering opacity equal to kappa=02(1+X)textcm^2g^-1 is available.\n\nvarnames = [:lnρ, :lnT, :lnr, :lum]\nvarscaling = [:log, :log, :log, :maxval]\nstructure_equations = [Evolution.equationHSE, Evolution.equationT,\n                       Evolution.equationContinuity, Evolution.equationLuminosity]\nremesh_split_functions = [StellarModels.split_lnr_lnρ, StellarModels.split_lum,\n                          StellarModels.split_lnT, StellarModels.split_xa]\nnet = NuclearNetwork([:H1, :He4, :C12, :N14, :O16], [(:kipp_rates, :kipp_pp), (:kipp_rates, :kipp_cno)])\nnz = 1000\nnextra = 100\neos = EOS.IdealEOS(true)\nopacity = Opacity.SimpleElectronScatteringOpacity()\nturbulence = Turbulence.BasicMLT(1.0)\nsm = StellarModel(varnames, varscaling, structure_equations, Evolution.equation_composition,\n                    nz, nextra, remesh_split_functions, net, eos, opacity, turbulence);\nnothing #hide","category":"section"},{"location":"NuclearBurning/#Initialize-StellarModel-and-evaluate-equations-and-jacobian","page":"NuclearBurning.jl","title":"Initialize StellarModel and evaluate equations and jacobian","text":"We do not have a working initial condition yet. We require pressure, temperature profiles. One simple available initial condition is that of an n=1 polytrope. This sets the pressure and density and computes the temperature from the EOS. The luminosity is initialized by assuming pure radiative transport for the temperature gradient produced by the polytrope. Information of the model at its present and following step are required at the beginning, the function compute_starting_model_properties! takes care of setting this up.\n\nn = 3\nStellarModels.n_polytrope_initial_condition!(n, sm, nz, 0.7154, 0.0142, 0.0, Chem.abundance_lists[:ASG_09], MSUN,\n                                             100 * RSUN; initial_dt=10 * SECYEAR)\nEvolution.compute_starting_model_properties!(sm)","category":"section"},{"location":"NuclearBurning/#Benchmarking","page":"NuclearBurning.jl","title":"Benchmarking","text":"The previous code leaves everything ready to solve the linearized system. For now we make use of a the serial Thomas algorithm for tridiagonal block matrices. We first show how long it takes to evaluate the Jacobian matrix. This requires two steps, the first is to evaluate properties across the model (for example, the EOS) and then evaluate all differential equations and fill the Jacobian. We first benchmark the evaluation of model properties:\n\n@benchmark begin\n    StellarModels.evaluate_stellar_model_properties!($sm, $sm.props)\nend\n\nAnd next we benchmark the evaluation of the model equations and construction of the Jacobian:\n\n@benchmark begin\n    Evolution.eval_jacobian_eqs!($sm)\nend\n\nTo benchmark the linear solver itself we need to perform the jacobian evaluation as a setup for the benchmark. This is because the solver destroys the Jacobian to perform in-place operations.\n\n@benchmark begin\n    Evolution.thomas_algorithm!($sm)\nend setup=(Evolution.eval_jacobian_eqs!($sm))","category":"section"},{"location":"NuclearBurning/#Evolving-our-model","page":"NuclearBurning.jl","title":"Evolving our model","text":"We can now evolve our star! We will initiate a 1M_odot star with a radius of 100R_odot using an n=3 polytrope. The star is expected to contract until it ignites hydrogen. We set a few options for the simulation with a toml file, which we generate dynamically. These simulation should complete in about a thousand steps once it reaches the max_center_T limit.\n\nOutput is stored in HDF5 files, and easy to use functions are provided with the StellarModels module to turn these HDF5 files into DataFrame objects. HDF5 output is compressed by default.\n\nopen(\"example_options.toml\", \"w\") do file\n    write(file,\n          \"\"\"\n          [remesh]\n          do_remesh = true\n\n          [solver]\n          newton_max_iter_first_step = 1000\n          initial_model_scale_max_correction = 0.2\n          newton_max_iter = 10\n          scale_max_correction = 0.1\n\n          [timestep]\n          dt_max_increase = 1.5\n          delta_R_limit = 0.01\n          delta_Tc_limit = 0.01\n          delta_Xc_limit = 0.005\n\n          [termination]\n          max_model_number = 2000\n          max_center_T = 1e8\n\n          [io]\n          profile_interval = 50\n          terminal_header_interval = 100\n          terminal_info_interval = 100\n\n          \"\"\")\nend\nStellarModels.set_options!(sm.opt, \"./example_options.toml\")\nrm(sm.opt.io.hdf5_history_filename; force=true)\nrm(sm.opt.io.hdf5_profile_filename; force=true)\n\n\n#Configure live plots. To turn off one can use `plotter = Plotting.NullPlotter()`\nusing GLMakie\nGLMakie.activate!()\nset_theme!(Plotting.basic_theme())\nf = Figure(size=(1400,750))\nplots = [Plotting.HRPlot(f[1,1]),\n         Plotting.TRhoProfile(f[1,2]),\n         Plotting.KippenLine(f[2,1], xaxis=:time, time_units=:Gyr),\n         Plotting.AbundancePlot(f[2,2],net,log_yscale=true, ymin=1e-3),\n         Plotting.HistoryPlot(f[1,3], sm, x_name=\"age\", y_name=\"X_center\", othery_name=\"Y_center\", link_yaxes=true),\n         Plotting.ProfilePlot(f[2,3], sm, x_name=\"mass\", y_name=\"log10_rho\", othery_name=\"log10_T\")]\nplotter = Plotting.Plotter(fig=f,plots=plots)\n\n\n#set initial condition and run model\nn = 3\nStellarModels.n_polytrope_initial_condition!(n, sm, nz, 0.7154, 0.0142, 0.0, Chem.abundance_lists[:ASG_09],\n                                            1 * MSUN, 100 * RSUN; initial_dt=10 * SECYEAR)\n@time Evolution.do_evolution_loop!(sm, plotter=plotter);\nnothing #hide","category":"section"},{"location":"NuclearBurning/#Plotting-with-Makie","page":"NuclearBurning.jl","title":"Plotting with Makie","text":"Now that our simulation is complete we can analyze the results. We make use of the Makie package for this. I'm not a fan of the Makie defaults, so I adjust them.\n\nusing CairoMakie, LaTeXStrings\nset_theme!(Plotting.basic_theme())","category":"section"},{"location":"NuclearBurning/#Compare-against-polytropes","page":"NuclearBurning.jl","title":"Compare against polytropes","text":"Below we see how the profile of the star compares to different polytropes. We make use of the facility tools to obtain DataFrame objects out of the hdf5 output. In particular, get_profile_names_from_hdf5 will provide the names of all profiles contained within the hdf5 file, while get_profile_dataframe_from_hdf5 is used to obtain one DataFrame corresponding to one stellar profile. The animation is constructed using the Observable type that makie provides. Note that the zero points of the polytropes are arbitrary.\n\nprofile_names = StellarModels.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nf = Figure();\nax = Axis(f[1, 1]; xlabel=L\"\\log_{10}(\\rho/\\text{[g\\;cm^{-3}]})\", ylabel=L\"\\log_{10}(P/\\text{[dyn]})\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(StellarModels.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\nlog10_ρ = @lift($profile[!, \"log10_rho\"])\nlog10_P = @lift($profile[!, \"log10_P\"])\n\nprofile_line = lines!(ax, log10_ρ, log10_P; label=\"real profile\")\nxvals = LinRange(-13, 4, 100)\nlines!(ax, xvals, (1 + 1 / 1) .* xvals .+ 20; label=\"n=1\")\nlines!(ax, xvals, (1 + 1 / (1.5)) .* xvals .+ 15; label=\"n=1.5\")\nlines!(ax, xvals, (1 + 1 / 3) .* xvals .+ 15; label=\"n=3\")\naxislegend(ax; position=:rb)\n\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\nprofile_text = text!(ax, -10, 20; text=model_number_str)\n\nrecord(f, \"rho_P_evolution.gif\", profile_names[1:end]; framerate=4) do profile_name\n    pname[] = profile_name\nend\n\n(Image: Movie polytrope)","category":"section"},{"location":"NuclearBurning/#Check-nuclear-burning","page":"NuclearBurning.jl","title":"Check nuclear burning","text":"We see that the structure evolves towards an n=3 polytrope. Deviations near the core are due to the non-homogeneous composition as hydrogen is burnt. We can similarly visualize how the hydrogen mass fraction changes in the simulation. In here, only one frame shows the hydrogen that was burnt. To better visualize that you can adjust profile_interval in the IO options (and probably adjust the framerate).\n\nprofile_names = StellarModels.get_profile_names_from_hdf5(\"profiles.hdf5\")\n\nf = Figure();\nax = Axis(f[1, 1]; xlabel=L\"\\text{Mass}\\;[M_\\odot]\", ylabel=L\"\\text{Abundance}\")\n\npname = Observable(profile_names[1])\n\nprofile = @lift(StellarModels.get_profile_dataframe_from_hdf5(\"profiles.hdf5\", $pname))\nmass = @lift($profile[!, \"mass\"])\nX = @lift($profile[!, \"X\"])\nY = @lift($profile[!, \"Y\"])\nmodel_number_str = @lift(\"model number=$(parse(Int,$pname))\")\n\nprofile_line = lines!(ax, mass, X; label=\"X\")\nprofile_line = lines!(ax, mass, Y; label=\"Y\")\nprofile_text = text!(ax, 0.7, 0.95; text=model_number_str)\naxislegend(ax; position=:rb)\nylims!(ax,-0.05,1.05)\n\nrecord(f, \"X_evolution.gif\", profile_names[1:end]; framerate=4) do profile_name\n    pname[] = profile_name\nend\n\n(Image: Movie polytrope)","category":"section"},{"location":"NuclearBurning/#Plot-a-funny-HR-diagram","page":"NuclearBurning.jl","title":"Plot a funny HR diagram","text":"Finally, we can also access the history data of the simulation. We use this to plot a simple HR diagram. As our microphysics are very simplistic, and the initial condition is not very physical, this looks a bit funny!\n\nf = Figure();\nax = Axis(f[1, 1]; xlabel=L\"\\log_{10}(T_\\text{eff}/[K])\", ylabel=L\"\\log_{10}(L/L_\\odot)\", xreversed=true)\nhistory = StellarModels.get_history_dataframe_from_hdf5(\"history.hdf5\")\nlines!(ax, log10.(history[!, \"T_surf\"]), log10.(history[!, \"L_surf\"]))\nf","category":"section"},{"location":"NuclearBurning/#Perform-some-cleanup","page":"NuclearBurning.jl","title":"Perform some cleanup","text":"Internally we want to prevent storing any of the hdf5 files into our git repos, so I remove them. You can also take advantage of julia as a scripting language to post-process your simulation output in a similar way.\n\nrm(\"history.hdf5\")\nrm(\"profiles.hdf5\")\nrm(\"example_options.toml\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"Turbulence/#Turbulence","page":"Turbulence","title":"Turbulence","text":"The Turbulence module of Jems handles all things related to turbulence and convection inside stars.","category":"section"},{"location":"Turbulence/#Jems.Turbulence.AbstractTurb","page":"Turbulence","title":"Jems.Turbulence.AbstractTurb","text":"abstract type AbstractTurb\n\nAbstract supertype from which all turbulence models must derive, ie:\n\nstruct MyTurb <: AbstractTurb\n\n\n\n\n\n","category":"type"},{"location":"Turbulence/#Jems.Turbulence.BasicMLT","page":"Turbulence","title":"Jems.Turbulence.BasicMLT","text":"struct AdiabaticMLT <: AbstractTurb\n\nDefinitions used for MLT without inclusion of radiative losses\n\n\n\n\n\n","category":"type"},{"location":"Turbulence/#Jems.Turbulence.TurbResults","page":"Turbulence","title":"Jems.Turbulence.TurbResults","text":"mutable struct TurbResults{T1}\n\nStructure that holds various results from the evaluation of the turbulence model of a certain cell.\n\n\n\n\n\n","category":"type"},{"location":"Turbulence/#Jems.Turbulence.cgMLT","page":"Turbulence","title":"Jems.Turbulence.cgMLT","text":"struct cgMLT <: AbstractTurb\n\nDefinitions used for MLT with inclusion of radiative losses\n\n\n\n\n\n","category":"type"},{"location":"DualSupport/#DualSupport","page":"DualSupport","title":"DualSupport","text":"Module containing functions that manage dual numbers used in Jems.jl.","category":"section"},{"location":"DualSupport/#Jems.DualSupport.StarDiffCache","page":"DualSupport","title":"Jems.DualSupport.StarDiffCache","text":"struct StarDiffCache{SIZE, TNUMBER}\n\nDefinition of StarDiffCache, a cache that makes room to store partial derivatives. Parametric in types SIZE, the size of the array, and TNUMBER, the type of the number used for calculations. \n\n\n\n\n\n","category":"type"},{"location":"DualSupport/#Jems.DualSupport.StarDiffCache-Union{Tuple{TNUMBER}, Tuple{Int64, Type{TNUMBER}}} where TNUMBER","page":"DualSupport","title":"Jems.DualSupport.StarDiffCache","text":"function StarDiffCache(nvars::Int, ::Type{TNUMBER}) where {TNUMBER}\n\nInstantiates a StarDiffCache object of size nvars+1, and fills it with zeros.\n\n\n\n\n\n","category":"method"},{"location":"DualSupport/#Jems.DualSupport.CellDualData","page":"DualSupport","title":"Jems.DualSupport.CellDualData","text":"struct CellDualData{NVARSP1, THREENVARSP1, TNUMBER}\n\nDefinition of CellDualData, that holds the information needed to construct partial derivatives wrt its own properties as well as its neighbors. Parametric in types NVARSP1, the number of independent variables plus one, THREENVARSP1, three times the number of independe variables plus one, and TNUMBER, the type of the number used for the calculations (usually floats, but can be duals themselves).\n\n\n\n\n\n","category":"type"},{"location":"DualSupport/#Jems.DualSupport.CellDualData-Union{Tuple{TNUMBER}, Tuple{Int64, Type{TNUMBER}}} where TNUMBER","page":"DualSupport","title":"Jems.DualSupport.CellDualData","text":"function CellDualData(nvars::Int, ::Type{TNUMBER}; is_ind_var=false, ind_var_i=0)\n\nInstantiates an object of type CellDualData, that holds the information needed to construct partial derivatives wrt its own properties as well as its neighbors. Use is_ind_var=True and ind_var_i=i to instantiate a CellDualData of a base independent variable, with ones assigned in the appropriate spots\n\n\n\n\n\n","category":"method"},{"location":"DualSupport/#Base.convert-Union{Tuple{TN2}, Tuple{TN1}, Tuple{SIZE2}, Tuple{SIZE1}, Tuple{Type{Jems.DualSupport.CellDualData{SIZE1, SIZE2, TN1}}, TN2}} where {SIZE1, SIZE2, TN1<:Number, TN2<:Number}","page":"DualSupport","title":"Base.convert","text":"function Base.convert(::Type{CellDualData{SIZE1, SIZE2, TN1}}, x::TN2) where {SIZE1, SIZE2, TN1<:Number, TN2<:Number}\n\nConvert x of type TN2 to a CellDualData object of types SIZE1, SIZE2 and TN1.\n\n\n\n\n\n","category":"method"},{"location":"DualSupport/#Base.zero-Union{Tuple{Type{Jems.DualSupport.CellDualData{SIZE1, SIZE2, TNUMBER}}}, Tuple{TNUMBER}, Tuple{SIZE2}, Tuple{SIZE1}} where {SIZE1, SIZE2, TNUMBER}","page":"DualSupport","title":"Base.zero","text":"function Base.zero(::Type{CellDualData{SIZE1,SIZE2,TNUMBER}}) where {SIZE1, SIZE2, TNUMBER}\n\nInstantiates a CellDualData with zero entries (the neutral element for duals).\n\n\n\n\n\n","category":"method"},{"location":"DualSupport/#Jems.DualSupport.update_cell_dual_data!-Union{Tuple{TDSC}, Tuple{TNUMBER}, Tuple{SIZE2}, Tuple{SIZE1}, Tuple{Jems.DualSupport.CellDualData{SIZE1, SIZE2, TNUMBER}, TDSC}} where {SIZE1, SIZE2, TNUMBER, TDSC}","page":"DualSupport","title":"Jems.DualSupport.update_cell_dual_data!","text":"function update_cell_dual_data!(cd::CellDualData{SIZE1, SIZE2, TNUMBER}, dual::TDSC) where {SIZE1, SIZE2, TNUMBER, TDSC}\n\nUpdates all data of the CellDualData object to the data of a given dual number.\n\n\n\n\n\n","category":"method"},{"location":"DualSupport/#Jems.DualSupport.update_cell_dual_data_value!-Tuple{Jems.DualSupport.CellDualData, Any}","page":"DualSupport","title":"Jems.DualSupport.update_cell_dual_data_value!","text":"function update_cell_dual_data_value!(cd::CellDualData, value)\n\nUpdates all data of the CellDualData object to the given value.\n\n\n\n\n\n","category":"method"},{"location":"DualSupport/#Jems.DualSupport.FaceDualData","page":"DualSupport","title":"Jems.DualSupport.FaceDualData","text":"struct FaceDualData{TWONVARSP1, THREENVARSP1, TNUMBER}\n\nDefinition of FaceDualData, that holds the information needed to construct partial derivatives wrt its own properties (the face) as well as its neighbors. Parametric in types TWONVARSP1, two times the number of independent variables plus one, THREENVARSP1, three times the number of independe variables plus one, and TNUMBER, the type of the number used for the calculations (usually floats, but can be duals themselves).\n\n\n\n\n\n","category":"type"},{"location":"DualSupport/#Jems.DualSupport.FaceDualData-Union{Tuple{TNUMBER}, Tuple{Int64, Type{TNUMBER}}} where TNUMBER","page":"DualSupport","title":"Jems.DualSupport.FaceDualData","text":"function CellDualData(nvars::Int, ::Type{TNUMBER}; is_ind_var=false, ind_var_i=0)\n\nInstantiates an object of type FaceDualData, that holds the information needed to construct partial derivatives wrt its own properties as well as its neighbors.\n\n\n\n\n\n","category":"method"},{"location":"Opacity/#Opacity","page":"Opacity","title":"Opacity","text":"The Opacity module of Jems handles all things related to the opacity of stellar matter.","category":"section"},{"location":"Opacity/#Jems.Opacity.AbstractOpacity","page":"Opacity","title":"Jems.Opacity.AbstractOpacity","text":"abstract type AbstractOpacity\n\nAbstract supertype from which all defined opacity laws must derive, ie:\n\nstruct MyOpacity <: AbstractOpacity\n\n\n\n\n\n","category":"type"},{"location":"Opacity/#Jems.Opacity.get_opacity_resultsTρ-Union{Tuple{TT}, Tuple{Jems.Opacity.SimpleElectronScatteringOpacity, TT, TT, AbstractVector{<:TT}, Vector{Symbol}}} where TT<:Real","page":"Opacity","title":"Jems.Opacity.get_opacity_resultsTρ","text":"get_opacity_resultsTP(opacity::SimpleElectronScatteringOpacity, lnT::TT, lnP::TT, xa::Vector{<:TT},\n                        species::Vector{Symbol})::TT where {TT<:Real}\n\nEvaluates the opacity of the current mixture with mass fractions xa, species symbols species (both these should be of length nspecies), the natural log of temperature and pressure lnT, lnP, and the opacity law opacity.\n\n\n\n\n\n","category":"method"},{"location":"Constants/#Constants","page":"Constants","title":"Constants","text":"The Constants module of Jems defines a common set of physical and mathematical constants for use across the package. Currently not all constants are exported, so some of them need to be accesed by using the module name (e.g. Const.FINE).\n\nPages   = [\"Constants.md\"]","category":"section"},{"location":"Constants/#Jems.Constants.AMU","page":"Constants","title":"Jems.Constants.AMU","text":"AMU = 1.6605390666e-24\n\nAtomic mass unit in units of mathrmg\n\nSource: CODATA 2018\n\nHas a relative uncertainty of 3times10^-10\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.AU","page":"Constants","title":"Jems.Constants.AU","text":"AU = 1.49597870700e13\n\nAstronomical unit in mathrmcm.\n\nFrom \"The IAU 2009 system of astronomical constants: the report of the IAU working group on numerical standards for Fundamental Astronomy\".\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.AVO","page":"Constants","title":"Jems.Constants.AVO","text":"AVO = 6.02214076e23\n\nAvogadro's constant in units of mathrmmol^-1.\n\nSource CODATA 2018\n\nExact constant\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.CGAS","page":"Constants","title":"Jems.Constants.CGAS","text":"CGAS = K_BOLTZ * AVO = 8.31446261815324e7\n\nIdeal gas constant in units of mathrmergmathrmK^-1mathrmmol^-1\n\nExact constant\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.CGRAV","page":"Constants","title":"Jems.Constants.CGRAV","text":"CGRAV = 6.67430e-8\n\nGravitational constant in units of mathrmg^-1mathrmcm^3mathrms^-2\n\nSource: CODATA 2018\n\nHas a relative uncertainty of 22times10^-5\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.CLIGHT","page":"Constants","title":"Jems.Constants.CLIGHT","text":"CLIGHT = 2.99792458e10\n\nSpeed of light in units of mathrmcmmathrms^-1.\n\nSource CODATA 2018\n\nExact constant\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.CRAD","page":"Constants","title":"Jems.Constants.CRAD","text":"CRAD = SIGMA_SB * 4 / CLIGHT = 7.565733250280006e-15\n\nRadiation density constant in units of mathrmergmathrmcm^-3mathrmK^-4\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.DAYYEAR","page":"Constants","title":"Jems.Constants.DAYYEAR","text":"DAYYEAR = 365.25e0\n\nNumber of days in a year\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.EV_TO_ERG","page":"Constants","title":"Jems.Constants.EV_TO_ERG","text":"EV_TO_ERG = 1.602176634e-12\n\nEnergy of 1mathrmeV in  mathrmerg\n\nSource: CODATA 2018\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.FINE","page":"Constants","title":"Jems.Constants.FINE","text":"FINE = QE^2 / (HBAR * CLIGHT) = 0.007297352565305213\n\nFine structure constant\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.G_TIMES_MEARTH","page":"Constants","title":"Jems.Constants.G_TIMES_MEARTH","text":"G_TIMES_MEARTH = 3.986004e20\n\nProduct of the gravitational constant times the mass of the Earth. In units of mathrmcm^3mathrms^-2.\n\nTaken from the \"IAU 2015 Resolution B3 on Recommended Nominal Conversion Constants for Selected Solar and Planetary Properties\".\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.G_TIMES_MJUPITER","page":"Constants","title":"Jems.Constants.G_TIMES_MJUPITER","text":"G_TIMES_MJUPITER = 1.2668653e23\n\nProduct of the gravitational constant times the mass of Jupiter. In units of mathrmcm^3mathrms^-2.\n\nTaken from the \"IAU 2015 Resolution B3 on Recommended Nominal Conversion Constants for Selected Solar and Planetary Properties\".\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.G_TIMES_MSUN","page":"Constants","title":"Jems.Constants.G_TIMES_MSUN","text":"G_TIMES_MSUN = 1.3271244e26\n\nProduct of the gravitational constant times the mass of the Sun. In units of mathrmcm^3mathrms^-2.\n\nTaken from the \"IAU 2015 Resolution B3 on Recommended Nominal Conversion Constants for Selected Solar and Planetary Properties\".\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.HBAR","page":"Constants","title":"Jems.Constants.HBAR","text":"HBAR = PLANCK_H / (2 * pi) = 1.0545718176461565e-27\n\nReduced Planck constant in units of mathrmergmathrms\n\nSource: CODATA 2018\n\nExact constant\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.K_BOLTZ","page":"Constants","title":"Jems.Constants.K_BOLTZ","text":"K_BOLTZ = 1.380649e-16\n\nBoltzmann constant in units of mathrmerg^-1mathrmK^-1.\n\nSource CODATA 2018\n\nExact constant\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.LSUN","page":"Constants","title":"Jems.Constants.LSUN","text":"LSUN = 3.828e33\n\nSolar luminosity in mathrmergmathrms^-1.\n\nTaken from the \"IAU 2015 Resolution B3 on Recommended Nominal Conversion Constants for Selected Solar and Planetary Properties\".\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.LY","page":"Constants","title":"Jems.Constants.LY","text":"LY = CLIGHT*SECYEAR = 9.4607304725808e17\n\nLightyear in units of mathrmcm\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.ME","page":"Constants","title":"Jems.Constants.ME","text":"ME = 9.1093837015e-28\n\nElectron mass in units of mathrmg\n\nSource: CODATA 2018\n\nHas a relative uncertainty of 30times10^-10\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.MEARTH","page":"Constants","title":"Jems.Constants.MEARTH","text":"MEARTH = G_TIMES_MEARTH/CGRAV = 5.972167867791379e27\n\nMass of the Earth in mathrmg computed from the product GM.\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.MEV_TO_ERGS","page":"Constants","title":"Jems.Constants.MEV_TO_ERGS","text":"MEV_TO_ERG = 1e6 * EV_TO_ERG = 1.602176634e-6\n\nEnergy of 1mathrmMeV in  mathrmerg\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.MJUPITER","page":"Constants","title":"Jems.Constants.MJUPITER","text":"MJUPITER = G_TIMES_MJUPITER/CGRAV = 1.89812459733605e30\n\nMass of Jupiter in mathrmg computed from the product GM.\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.MN","page":"Constants","title":"Jems.Constants.MN","text":"MN = 1.6749274980e-24\n\nNeutron mass in units of mathrmg\n\nSource: CODATA 2018\n\nHas a relative uncertainty of 57times10^-10\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.MP","page":"Constants","title":"Jems.Constants.MP","text":"MP = 1.67262192369e-24\n\nNeutron mass in units of mathrmg\n\nSource: CODATA 2018\n\nHas a relative uncertainty of 31times10^-10\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.MSUN","page":"Constants","title":"Jems.Constants.MSUN","text":"MSUN = G_TIMES_MSUN/CGRAV = 1.9884098706980504e33\n\nMass of the Sun in mathrmg computed from the product GM.\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.PLANCK_H","page":"Constants","title":"Jems.Constants.PLANCK_H","text":"PLANCK_H = 6.62607015e-27\n\nPlanck constant in units of mathrmergmathrms\n\nSource: CODATA 2018\n\nExact constant\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.QE","page":"Constants","title":"Jems.Constants.QE","text":"QE = (CLIGHT/10)*1.602176634e-19 = 4.803204712570263e-10\n\nElectron charge in esu==(g cm^3 s^-2)^(1/2) converted from the electron charge in Coulomb.\n\nSource CODATA 2018\n\nExact constant\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.RBOHR","page":"Constants","title":"Jems.Constants.RBOHR","text":"RBOHR = HBAR^2 / (ME * QE^2) = 5.291772111941798e-9\n\nBohr radius in units of mathrmcm\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.RSUN","page":"Constants","title":"Jems.Constants.RSUN","text":"RSUN = 6.957e10\n\nSolar radius in mathrmcm.\n\nTaken from the \"IAU 2015 Resolution B3 on Recommended Nominal Conversion Constants for Selected Solar and Planetary Properties\".\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.SECYEAR","page":"Constants","title":"Jems.Constants.SECYEAR","text":"SECYEAR = DAYYEAR * 24 * 3600 = 3.15576e7\n\nNumber of seconds in a year.\n\n\n\n\n\n","category":"constant"},{"location":"Constants/#Jems.Constants.SIGMA_SB","page":"Constants","title":"Jems.Constants.SIGMA_SB","text":"SIGMA_SB = (2*π^5*K_BOLTZ^4)/(15*CLIGHT^2*PLANCK_H^3) = 5.67037441918443e-5\n\nStefan-Boltzmann constant in units of mathrmergmathrmcm^-2mathrmK^-4mathrms^-1\n\n\n\n\n\n","category":"constant"},{"location":"ReactionRates/#ReactionRates","page":"ReactionRates","title":"ReactionRates","text":"The ReactionRates module of Jems handles all things related to the nuclear reaction rates of mixtures.","category":"section"},{"location":"ReactionRates/#General-functionality","page":"ReactionRates","title":"General functionality","text":"The ReactionRates module has a simple structure, rates can be defined as subtypes of the abstract type Jems.ReactionRates.AbstractReactionRate. A function needs to be defined to compute the rate which dispatches based on the type of the reaction rate. Multiple rates can also be added to the Jems.reactions_list dictionary in order to construct nuclear reaction networks with the NuclearNetworks module.\n\nA simple example for this would be:\n\nusing Jems.ReactionRates\nusing Jems.Chem\nusing Jems.Constants\n\nstruct MyReactionRate{TT<:Real} <: ReactionRates.AbstractReactionRate\n    name::Symbol\n    iso_in::Vector{Symbol}\n    num_iso_in::Vector{Int}\n    iso_out::Vector{Symbol}\n    num_iso_out::Vector{Int}\n    Qvalue::TT\nend\n\nfunction ReactionRates.get_reaction_rate(reaction::MyReactionRate, T::T1, ρ::T2, xa::AbstractVector{TT}, xa_index::Dict{Symbol,Int})::TT where {TT,T1,T2}\n    rate = 0\n    if reaction.name == :my_h1_h1_to_d2\n        h1_index = xa_index[:H1]\n        h1 = xa[h1_index]\n        rate = h1^2 # mock example, we just have h1^2 reactions per second per gram.\n    end\n    return rate\nend\n\nmy_reaction = MyReactionRate(:my_h1_h1_to_d2, [:H1], [2], [:D2], [1], (2 * Chem.isotope_list[:H1].mass - Chem.isotope_list[:D2].mass) * AMU * CLIGHT^2)\n\n# evaluate this rate\nT = 1e9 # in K\nρ = 10 # in g cm^-3\nxa = [1.0, 0.0] # mass fractions, considering only H1 and H2, with 100% H1\nxa_index = Dict(:H1=>1, :H2=>2)\nReactionRates.get_reaction_rate(my_reaction, T, ρ, xa, xa_index)\n\n# store in reactions_list, this is done by creating a new dictionary for my rates, in this case with a single entry\nReactionRates.reaction_list[:my_rates] = Dict(:my_h1_h1_to_d2 => my_reaction)\n;\n\nFor more details check the documentation of Jems.ReactionRates.AbstractReactionRate and Jems.ReactionRates.reaction_list.","category":"section"},{"location":"ReactionRates/#Kippenhahn-rates","page":"ReactionRates","title":"Kippenhahn rates","text":"The Kippenhahn reaction rates are based on the Kippenhahn textbook on stellar structure and evolution. Rates are estimated simply by taking the values of epsilon_mathrmnuc derived using the formulae in the textbook and dividing by the Q value of the reaction, taken to be simply the mass difference. Rates available are:\n\n:kipp_pp: compound rate for the full pp-chain, takes 4 H1 and makes one He4\n:kipp_cno: compund rate for the full cno-chain, takes 4 H1 and makes one He4\n:kipp_3alphaCF88: TODO\n:kipp_3alphaA99: TODO\n:kipp_C12alpha: TODO\n:kipp_O16alpha: TODO\n:kipp_CC: TODO\n:kipp_OO: TODO\n\nThe rates are stored in reactions_list[:kipp_rates], so they can be accesed as, for example, reactions_list[:kipp_rates][:kipp_pp].","category":"section"},{"location":"ReactionRates/#JINA-rates","page":"ReactionRates","title":"JINA rates","text":"TODO: Jina rates have a bunch of extra functionality to help access independent reactions from their large library, need to describe these and possibly clean up the code there a bit. Jina specific functions should probably be renamed to make that clear.","category":"section"},{"location":"ReactionRates/#Toy-rates","page":"ReactionRates","title":"Toy rates","text":"Early rates used within the code based on the power law relationships given in the lecture notes on stellar evolution of Onno Pols. The lectures only provided relationships of the form epsilon_mathrmnucpropto rho T^nu, here we made an arbitrary choice for the pre-factor and determine the rate by dividing for the Q value. YOU ARE STRONGLY ADVISED NOT TO USE THESE RATES.\n\nRates available are:\n\n:toy_pp: Compound rate for the pp-chain. Uses epsilon_mathrmnucproptorho T^4.\n:toy_cno: Compound rate for the CNO cycle. Uses epsilon_mathrmnucproptorho T^18.\n\nThe rates are stored in reactions_list[:toy_rates], so they can be accesed as, for example, reactions_list[:kipp_rates][:toy_pp].","category":"section"},{"location":"ReactionRates/#Jems.ReactionRates.AbstractReactionRate","page":"ReactionRates","title":"Jems.ReactionRates.AbstractReactionRate","text":"abstract type AbstractReactionRate end\n\nReaction rates should be defined as a subtype of AbstractReactionRate. Any custom reaction rate needs to contain a set of fixed fields:\n\nstruct MyReactionRate{TT<:Real} <: ReactionRates.AbstractReactionRate\n    name::Symbol\n    # num_iso_in of isotopes iso_in are converted into num_iso_out of isotopes iso_out\n    iso_in::Vector{Symbol}\n    num_iso_in::Vector{Int}\n    iso_out::Vector{Symbol}\n    num_iso_out::Vector{Int}\n    Qvalue::TT  # energy released per reaction of this type (i.e. the mass defect), in erg\nend\n\narbitrary fields can be added here. For instance if you have a tabulated reaction rate you can add the table values or even include the data defining a specific interpolator for it.\n\nFor any custom rate the following function needs to be defined\n\nfunction get_reaction_rate(reaction::MyReactionRate, T::T1, ρ::T2, xa::AbstractVector{TT}\n    #insert your code here\nend\n\nthe function computes the specific reaction rate based on the name field of the reaction or done generically based on the other fields of the struct. Units are in mathrms^-1g^-1\n\n\n\n\n\n","category":"type"},{"location":"ReactionRates/#Jems.ReactionRates.reaction_list","page":"ReactionRates","title":"Jems.ReactionRates.reaction_list","text":"reaction_list::Dict{Symbol, Dict{Symbol,AbstractReactionRate}} = Dict()\n\nThe reaction_list dictionary contains reaction rates that are available for construction of nuclear reaction networks. It is a dictionary of dictionaries, for instance accessing reaction_list[:jina_rates] will provide all available rates from JINA.\n\nYou can add a new dictionary of rates to reaction_list by doing\n\nreaction_list[:kipp_rates] = Dict(\n    :kipp_pp => MyReactionRate(:my_pp, [:H1], [2], [:H2], [1],\n                                 ((2 * Chem.isotope_list[:H1].mass - Chem.isotope_list[:He2].mass) * AMU * CLIGHT^2)),\n                                 # add whatever more rates\n                                 )\n\nthis assumes a specific form for the constructor of MyReactionRate which only includes the mandatory fields, you can use any custom constructor for rate definitions which have more fields than the standard ones.\n\n\n\n\n\n","category":"constant"},{"location":"ReactionRates/#Jems.ReactionRates.KippReactionRate","page":"ReactionRates","title":"Jems.ReactionRates.KippReactionRate","text":"struct KippReactionRate{TT<:Real}<:ReactionRates.AbstractReactionRate\n\nStruct for a Kippenhahn reaction rate, as defined in the Kippenhahn textbook. Results are evaluated by using the specific formula needed based on the name of the reaction.\n\nname: Symbol giving the name of the reaction.\niso_in: vector that contains all reactants given as symbols (e.g. [:H1, :H2])\nnum_iso_in: number of each of the elements in iso_in that are used in the reaction, given as a vector of integers. For example if iso_in is [:He4] and num_iso_in is [3] it means the reaction uses three \":He4\".\niso_out: Same as iso_in but for the products of the reaction.\nnum_iso_out: Same as num_iso_in but for the products of the reaction.\nQvalue: Q-value of the reaction (in erg), simply given by the mass difference.\n\n\n\n\n\n","category":"type"},{"location":"ReactionRates/#Jems.ReactionRates.get_reaction_rate-Union{Tuple{T2}, Tuple{T1}, Tuple{TT}, Tuple{Jems.ReactionRates.KippReactionRate, T1, T2, AbstractVector{TT}, Dict{Symbol, Int64}}} where {TT, T1, T2}","page":"ReactionRates","title":"Jems.ReactionRates.get_reaction_rate","text":"function get_reaction_rate(reaction::KippReactionRate, T::T1, ρ::T2, xa::AbstractVector{TT},\n                            xa_index::Dict{Symbol,Int})::TT where {TT,T1,T2}\n\nInput: reaction: the reaction to evaluate for\n\nT`: the temperature in K\nρ`: the density g cm^-3\nxa`: element mass fractions\nxa_index: Dictionary containing the index of each element within xa\n\nOutput:\n\nϵ_nuc / Qvalue, has units s^-1 g^-1\n\n\n\n\n\n","category":"method"},{"location":"ReactionRates/#Jems.ReactionRates.JinaReactionRate","page":"ReactionRates","title":"Jems.ReactionRates.JinaReactionRate","text":"JinaReactionRate{TT<:Real}<:ReactionRates.AbstractReactionRate\n\nStruct that holds the following information for a given reaction rate:\n\nTODO: explain all the different details that are read from the JINA data\n\nname: Symbol giving the name of the reaction.\niso_in: vector that contains all reactants given as symbols (e.g. [:H1, :H2])\nnum_iso_in: number of each of the elements in iso_in that are used in the reaction, given as a vector of integers. For example if iso_in is [:He4] and num_iso_in is [3] it means the reaction uses three \":He4\".\niso_out: Same as iso_in but for the products of the reaction.\nnum_iso_out: Same as num_iso_in but for the products of the reaction.\nQvalue: Q-value of the reaction (in erg), read from th JINA tables but its simply given by the mass difference.\ncoeff: different a_i values of the fit to the reaction. Contains a vector of 7 values.\nset_label: Symbol containing set label of the reaction\nres_rate: A 1 character flag symbol:\nwhen blank or n it is a non-resonant rate\nwhen r it is a resonant rate\nwhen w it is a weak rate.\nrev_rate: a 1 character flag symbol which is set to 'v' when it is a reverse rate.\nchapter: chapter this reaction is in. Different chapters\n\n\n\n\n\n","category":"type"},{"location":"ReactionRates/#Jems.ReactionRates.get_reaction_rate-Union{Tuple{T2}, Tuple{T1}, Tuple{TT}, Tuple{Jems.ReactionRates.JinaReactionRate, T1, T2, AbstractVector{TT}, Dict{Symbol, Int64}}} where {TT, T1, T2}","page":"ReactionRates","title":"Jems.ReactionRates.get_reaction_rate","text":"get_reaction_rate(reaction::JinaReactionRate, T::T1, ρ::T2, xa::AbstractVector{TT}, \n                  xa_index::Dict{Symbol,Int})\n\nEvaluates the reaction rate, in s^{-1}g^{-1}, by computing Eqs. 1 and 2 from Cyburt+2010.\n\n\n\n\n\n","category":"method"},{"location":"ReactionRates/#Jems.ReactionRates.read_dataset","page":"ReactionRates","title":"Jems.ReactionRates.read_dataset","text":"function read_dataset(dataset, dictionary, reference_dictionary)\n\nParses a large string object dataset, containing JINA reaction rate data, into a main dictionary and a reference dictionary. The main dictionary has entries with unique keys for every reaction rate in the database (double entries are distinguised with _0, _1 at the end of their key Symbol), while the reference dictionary has one entry per reaction equation, but has as value a list of all JINA rates for that reaction equation.\n\nExample: if H1 + H1 -> D2 has two rates in the JINA database, main dictionary will contain:\n\ndictionary[:H1_H1_to_D2_0] = _rate_info_(...)\ndictionary[:H1_H1_to_D2_1] = _rate_info_(...)\n\nwhile the reference dict will contain:\n\nreference_dictionary[:H1_H1_to_D2] = [:H1_H1_to_D2_0, :H1_H1_to_D2_1]\n\nFor rates with only one entry in the JINA database, only an \"_0\" entry is made in the main dictionary, and the reference dictionary contains the list with only that one key.\n\n\n\n\n\n","category":"function"},{"location":"ReactionRates/#Jems.ReactionRates.add_to_references","page":"ReactionRates","title":"Jems.ReactionRates.add_to_references","text":"add_to_references(main_dict, ref_dict, reaction, new_info::JinaReactionRate)\n\nFunction to identify rates with the same reaction equation Evaluates if a reaction rate is already in the reference dictionary ref_dict\n\nIf the reaction rate does not exist already in the reference dictionary: added as a new key to the reference dictionary the value of the key is a list containing all variations of the specific reaction the reaction will be added to the main dictionary\n\nIf the reaction rate already exists in the reference dictionary: keys in the main dictionary update so they have unique keys value of the key of the reaction in ref_dict is updated so all the unique versions of the rate are in\n\n\n\n\n\n","category":"function"},{"location":"ReactionRates/#Jems.ReactionRates.correct_names","page":"ReactionRates","title":"Jems.ReactionRates.correct_names","text":"correct_names(JINA_name)\n\nReturns the name that corresponds with the JEMS isotope database, given JINA_name, the name of the element as it is given in the JINA library (without the extra spaces).\n\n\n\n\n\n","category":"function"},{"location":"ReactionRates/#Jems.ReactionRates.sort_reaction","page":"ReactionRates","title":"Jems.ReactionRates.sort_reaction","text":"function sort_reaction(elements)\n\nExtracts the unique elements and the amount of times they appear in the list elements.\n\n\n\n\n\n","category":"function"},{"location":"ReactionRates/#Jems.ReactionRates.ToyReactionRate","page":"ReactionRates","title":"Jems.ReactionRates.ToyReactionRate","text":"struct ToyReactionRate{TT<:Real}<:ReactionRates.AbstractReactionRate\n\nname: Symbol giving the name of the reaction.\niso_in: vector that contains all reactants given as symbols (e.g. [:H1, :H2])\nnum_iso_in: number of each of the elements in iso_in that are used in the reaction, given as a vector of integers. For example if iso_in is [:He4] and num_iso_in is [3] it means the reaction uses three \":He4\".\niso_out: Same as iso_in but for the products of the reaction.\nnum_iso_out: Same as num_iso_in but for the products of the reaction.\nQvalue: Q-value of the reaction (in erg), simply given by the mass difference.\n\n\n\n\n\n","category":"type"},{"location":"ReactionRates/#Jems.ReactionRates.get_reaction_rate-Union{Tuple{T2}, Tuple{T1}, Tuple{TT}, Tuple{Jems.ReactionRates.ToyReactionRate, T1, T2, AbstractVector{TT}, Dict{Symbol, Int64}}} where {TT, T1, T2}","page":"ReactionRates","title":"Jems.ReactionRates.get_reaction_rate","text":"function get_reaction_rate(reaction::ToyReactionRate, T::T1, ρ::T2, xa::AbstractVector{TT},\n                            xa_index::Dict{Symbol,Int})::TT where {TT,T1,T2}\n\nInput: reaction: the reaction to evaluate for\n\nT`: the temperature in K\nρ`: the density g cm^-3\nxa`: element mass fractions\nxa_index: Dictionary containing the index of each element within xa\n\nOutput:\n\nϵ_nuc / Qvalue, has units s^-1 g^-1\n\n\n\n\n\n","category":"method"},{"location":"DualNumbers/#DualSupport.jl","page":"DualSupport.jl","title":"DualSupport.jl","text":"An important part of the design of Jems is the thorough use of Dual numbers to compute partial derivatives with respect to all independent variables across the entire code. By independent variables traditionally in a Lagrangian stellar evolution code one refers to two thermodynamic properties (eg T and rho), the luminosity L and the radius r which are functions of the mass coordinate, plus the mass fractions of all isotopes that are being tracked. This means we have a total number of independent variables n_mathrmvars=4+n_mathrmspecies, where n_mathrmspecies is the number of isotopes included in the model. It can be hard to track how these utilities are used within the code, so the idea of this example is to show how they can be used for a much simpler physical system.","category":"section"},{"location":"DualNumbers/#Dual-numbers-and-caches","page":"DualSupport.jl","title":"Dual numbers and caches","text":"Let's first illustrate some basics about Dual numbers. We can create a Dual number using the implementation of the package ForwardDiff.jl. We consider functions of two variables x and y for which we will want partial derivatives. We can initialize dual numbers for these as (TODO: maybe show usage of tags to avoid autodiff confusion)\n\nimport ForwardDiff: Dual, Tag\n\nxfloat = 3.0\nyfloat = 2.0\nx = Dual(xfloat,(1.0,0.0))\ny = Dual(yfloat,(0.0,1.0))\n\nIn here the first number given to the Dual constructor is the value of the variable, meaning I set x=3 and y=3, while the tuple that follows are the partial derivatives with respect to x and y. For each of these we just have partial ypartial y=1 and partial xpartial x=1. Next we can perform some operations with these numbers and verify that we obtain the expected result and partial derivatives (assert will throw an exception if the approximate equality is not satisfied):\n\nfunction test(x,y)\n    #the partial derivatives for this one are\n    #∂f/∂x = cos(y), ∂f/∂y=-x*sin(y)\n    return x*cos(y)\nend\nresult = test(x,y)\n\n@assert result.value ≈ test(xfloat,yfloat)\n@assert result.partials[1] ≈ cos(yfloat)\n@assert result.partials[2] ≈ -xfloat*sin(yfloat)\n\nOne important issue with the use of dual numbers is that constantly creating them can produce a lot of allocations leading to significant slowdown. We can work around this issue by using a cache, which is precisely what the struct StarDiffCache is meant to do (the implementation of this struct was adapted from PreallocationTools.jl). Considering a case with n_mathrmvars=2, we need a cache that can store three values (that of the variable and that of the partial derivatives). We make here a cache for both x and y, this is very low level and very likely you will not need to interact with it.\n\nimport Jems.DualSupport: StarDiffCache, get_dual\n\ncache_x = StarDiffCache{3,Float64}(zeros(3))\ncache_x.dual_data[2] = 1.0 # dual_data[1] contains the value, dual_data[2] is ∂x/∂x=1, dual_data[3] is ∂x/∂y=0\n\ncache_y = StarDiffCache{3,Float64}(zeros(3))\ncache_y.dual_data[3] = 1.0; # dual_data[1] contains the value, dual_data[2] is ∂x/∂x=1, dual_data[3] is ∂x/∂y=0\n\n#we can repeat the example from above using these\n#first set the value of each dual number, which goes into the first entry of `dual_data`\ncache_x.dual_data[1] = xfloat\ncache_y.dual_data[1] = yfloat\n\nx = get_dual(cache_x)\ny = get_dual(cache_y)\nresult = test(x,y)\n\n@assert result.value ≈ test(xfloat,yfloat)\n@assert result.partials[1] ≈ cos(yfloat)\n@assert result.partials[2] ≈ -xfloat*sin(yfloat)","category":"section"},{"location":"DualNumbers/#CellDualData-for-calculations-in-a-three-point-stencil","page":"DualSupport.jl","title":"CellDualData for calculations in a three-point stencil","text":"An extra level of complexity is concerned with how the equations of stellar structure and evolution are solved. Consider for instance the equation of hydrostatic equilibrium:\n\nfracpartial Ppartial m=-fracGm4pi r^4\n\nAlthough we are looking for continuous solutions P(m) and r(m), for numerical purposes we need a discretization. The precise locations where pressure and radii are defined for a spherical shell can differ (a staggered mesh, see for instance Figure 9 of Paxton et al. 2011). For simplicity lets define all properties at cell centers, consider all cells of equal mass Delta m and estimate derivatives with a three point stencil. The above equation can then be written as:\n\nfracP_i+1-P_i-12Delta m + fracG m_i4pi r_i^4 = 0\n\nHere P_i, r_i and m_i correspond to the pressure, radius and mass at the center of cell i (where the index increases towards the center). In a Lagrangian code we have fixed cells, meaning m_i is known, and we want to find the values for all other variables in all zones (in this case P_i and r_i) for which the above equation is fulfilled. For clarity in this example, lets set everything except pressure and radii to unity,\n\nP_i+1-P_i-1+r_i^-4=0\n\nThe idea is that we will start with a guess for the solution to this equation (in an actual evolutionary model this can be the previous step properties or an initial condition defined with, for example, a solution to the Lane-Emden equation). The guess contains all values for pressure and density everywhere in the model, but since they need not satisfy hydrostatic equilibrium exactly we can define a residual to the equation of hydrostatic equilibrium at this cell,\n\nf_i = P_i+1-P_i-1+r_i^-4\n\nIn reality we have more differential equations of stellar structure that we need to consider (normally one per independent variable), and to solve them we make use of a Newton-Rhapson solver which attempts to find a set of values for the independent variables across the entire model that satisfy all the discretized equations. For this purpose we need not only evaluate the residual, but also evaluate all relevant non-zero partial derivatives, which in this case are\n\nfracpartial f_ipartial P_i+1=1quad fracpartial f_ipartial P_i-1=-1quad fracpartial f_ipartial r_i=-4 r_i^-5\n\nSo from this we see, we are considering two independent variables P and r, but the partial derivatives we need from the residuals need to be taken against the independent variables above, below and at the present cell. In general, for each residual we need 3n_mathrmvars partial derivatives, although typically many are equal to zero. A standard practice is just to hard code the partial derivatives as determined from the analytical expressions, but for complex calculations this can be very cumbersome and error prone. So the idea is to setup automatic differentiation tools that take care of this. This is the purpose of the CellDualData struct. We start by initializing 6 different CellDualData to represent densities and pressures around a point in the three-point stencil:\n\nusing Jems.DualSupport\n\nnvars = 2\n\nP_m1 = CellDualData(nvars, Float64; is_ind_var=true, ind_var_i=1) # this is pressure at the cell below\nP_00 = CellDualData(nvars, Float64; is_ind_var=true, ind_var_i=1) # this is pressure at the current cell\nP_p1 = CellDualData(nvars, Float64; is_ind_var=true, ind_var_i=1) # this is pressure at the cell above\n#initialize them with arbitrary values\nupdate_cell_dual_data_value!(P_m1, 0.9)\nupdate_cell_dual_data_value!(P_00, 1.0)\nupdate_cell_dual_data_value!(P_p1, 1.0)\n\n#same for density\nr_m1 = CellDualData(nvars, Float64; is_ind_var=true, ind_var_i=2) # this is pressure at the cell below\nr_00 = CellDualData(nvars, Float64; is_ind_var=true, ind_var_i=2) # this is pressure at the current cell\nr_p1 = CellDualData(nvars, Float64; is_ind_var=true, ind_var_i=2) # this is pressure at the cell above\n#initialize them with arbitrary values\nupdate_cell_dual_data_value!(r_m1, 1.0)\nupdate_cell_dual_data_value!(r_00, 1.0)\nupdate_cell_dual_data_value!(r_p1, 1.0);\nnothing #hide\n\nWith this in place we can create dual numbers and operate on them. We do this using the get_00_dual, get_m1_dual and get_p1_dual. This ensures the partial derivatives are filled in the way we want. To illustrate this, let's see the partials produced by the following\n\nP_m1_dual = get_m1_dual(P_m1)\nr_m1_dual = get_m1_dual(r_m1)\nP_00_dual = get_00_dual(P_00)\nr_00_dual = get_00_dual(r_00)\nP_p1_dual = get_p1_dual(P_p1)\nr_p1_dual = get_p1_dual(r_p1)\n\n@show P_m1_dual.partials\n@show r_m1_dual.partials\n@show P_00_dual.partials\n@show r_00_dual.partials\n@show P_p1_dual.partials\n@show r_p1_dual.partials;\nnothing #hide\n\nAs you can see we have dual numbers with a total of 6 partial derivatives. When combining these together to compute a residual f_i, the partial derivatives will contain (in order)\n\nfracpartial f_ipartial P_i-1fracpartial f_ipartial r_i-1fracpartial f_ipartial P_ifracpartial f_ipartial r_ifracpartial f_ipartial P_i+1fracpartial f_ipartial r_i+1\n\nWe can directly evaluate the equation for f_i that we used above and verify this works.\n\nf_i = P_p1_dual-P_m1_dual+r_00_dual^(-4)\n\n#verify non-zero partials\n@assert f_i.partials[1] ≈ -1 # This is testing \\partial f_i/ \\partial P_{i-1}\n@assert f_i.partials[4] ≈ -4*r_00_dual.value^5 # This is testing \\partial f_i/ \\partial r_{i}\n@assert f_i.partials[5] ≈ 1 # This is testing \\partial f_i/ \\partial P_{i}","category":"section"},{"location":"DualNumbers/#Evaluating-and-storing-results-into-CellDualData-instances-(TODO)","page":"DualSupport.jl","title":"Evaluating and storing results into CellDualData instances (TODO)","text":"","category":"section"},{"location":"DualNumbers/#A-simple-example-including-a-Newton_Rhapson-solver-(TODO)","page":"DualSupport.jl","title":"A simple example including a Newton_Rhapson solver (TODO)","text":"Here I want to show a simple system with a known solution, a vertical tube with an ideal gas fixed at constant temperatur, where the idea is to determine the density profile at arbitrary heights when there is a constant gravity.","category":"section"},{"location":"DualNumbers/#Further-complications,-FaceDualData-(TODO)","page":"DualSupport.jl","title":"Further complications, FaceDualData (TODO)","text":"Properties evaluated at faces are defined differently, need to also summarize why and how.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"Plotting/#Plotting","page":"Plotting","title":"Plotting","text":"This module provides live plotting routines for simulations","category":"section"},{"location":"Plotting/#Plotting.jl","page":"Plotting","title":"Plotting.jl","text":"","category":"section"},{"location":"Plotting/#Init.jl","page":"Plotting","title":"Init.jl","text":"","category":"section"},{"location":"Plotting/#History.jl","page":"Plotting","title":"History.jl","text":"","category":"section"},{"location":"Plotting/#HRD.jl","page":"Plotting","title":"HRD.jl","text":"","category":"section"},{"location":"Plotting/#TRhoProfile.jl","page":"Plotting","title":"TRhoProfile.jl","text":"","category":"section"},{"location":"Plotting/#Profile.jl","page":"Plotting","title":"Profile.jl","text":"","category":"section"},{"location":"#Jems.jl","page":"Home","title":"Jems.jl","text":"Documentation for Jems.jl.\n\nJems is a package designed for performing stellar structure and evolution calculations. Its main module is Evolution where a stellar model can be evolved according to user-defined equations. On the other hand, all the other modules can be used independently through their public interfaces.\n\nJems contains the following modules:\n\nPages = [\n    \"Chem.md\",\n    \"Constants.md\",\n    \"DualSupport.md\",\n    \"EOS.md\",\n    \"Evolution.md\",\n    \"Opacity.md\",\n    \"ReactionRates.md\",\n    \"StellarModels.md\"\n]","category":"section"}]
}
